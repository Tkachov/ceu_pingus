#ifndef PINGU_HOLDER_CEU
#define PINGU_HOLDER_CEU

#include "../c.ceu"
#include "../sdl.ceu"
#include "pingu.ceu"

native/pre do
    ##include "pingus/pingu_holder.hpp"
    ##define Package PinguHolder::PinguPackage
    ##define GetPackage PinguHolder::GetPinguPackage
    ##define new_Pingu new Pingu
end

input _Package* NEW_PINGU;
input _GetPackage* GET_PINGU;
input _PinguHolder* DELETE_PINGU_HOLDER;

native @pure _new_Pingu();

class PinguHolder with
    var _PinguHolder& me;
    pool Pingu[] all_pingus;
do
    var _PinguHolder&? me_ = _PTR2REF((_PinguHolder*)&this.me);
    var int all_pingus_size = 0;

    par/or do
        every package in NEW_PINGU do
            if package:holder != &me_ then
                continue;
            end

            if me_.number_of_allowed > all_pingus_size then
                // We use all_pingus.size() as pingu_id, so that id == array index
                spawn Pingu in all_pingus with
                    this.me = _new_Pingu(all_pingus_size, package:pos, package:owner);
                    package:result = &this.me;
                end;

                all_pingus_size = all_pingus_size + 1;
                me_.all_pingus_size = all_pingus_size;
            else
                package:result = 0;
            end
        end
    with
        every package in GET_PINGU do
            if package:holder != &me_ then
                continue;
            end

            package:result = 0;
            if package:id < all_pingus_size then                
                loop pingu in all_pingus do
                    if pingu:me.id == package:id then
                        if pingu:me.status == _PS_ALIVE then
                            package:result = _PTR2REF(&pingu:me);
                        end
                    end
                end
            end
        end
    with
        var _PinguHolder* p = await DELETE_PINGU_HOLDER until (p == &me_);
    end
end

#endif
