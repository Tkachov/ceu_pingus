#ifndef EXIT_CEU
#define EXIT_CEU

#include "../../c.ceu"
#include "../../sdl.ceu"
#include "../iworld.ceu"
#include "../worldobj.ceu"
#include "../ipingu_holder.ceu"
#include "../pingu_holder_listener.ceu"

native/pre do
    ##include "pingus/components/smallmap.hpp"
    ##include "pingus/res_descriptor.hpp"
    ##define new_ResDescriptor() new ResDescriptor()
    ##define colmap_remove(cm, desc, x, y) { CollisionMask __mask(*desc); cm->remove(__mask, x, y); }
end

native @pure _new_ResDescriptor(), _colmap_remove();

class Exit with
    interface IWorldObj;
    var _ResDescriptor&? desc;
    var int owner_id;

    var _Sprite&? sprite;
    var _Sprite&? flag;
    var _Sprite&? smallmap_symbol;
do
    function (_FileReader* reader) => void construct do
        //Unfortunately, we can't make `desc`/`sprite`/etc "private"
        //(i.e. hide it from interface in the body)
        //because this function's meant to be called in constructor
        //when the body is not executed yet

        reader:read_desc  ("surface",  _deref(desc));
        reader:read_int   ("owner-id", _PTR2REF(owner_id));

        // Set default owner ID to 0
        if owner_id<0 or owner_id>3 then
            owner_id = 0;
        end
    end;

    ///////////////////////////////////////////////////

    function (void) => float get_z_pos do
        return pos.z;
    end

    function (Vector3f p) => void set_pos do
        pos = p;
    end

    function (void) => Vector3f get_pos do
        return pos;
    end

    call/rec global:world:add_object(&this);

    finalize with
        _delete_obj(desc);
        _delete_obj(sprite);
        _delete_obj(flag);
        _delete_obj(smallmap_symbol);
    end;

    par/or do
        every gc in e_DRAW do
            _gc_color_draw2(gc, &sprite, _toVector3f(pos));
            _gc_color_draw2(gc, &flag, _toVector3f(pos) + _Vector3f(40, 0));
        end
    with
        every e_STARTUP do
            _colmap_remove(global:world:world:get_colmap(), desc, (int)pos.x - sprite.get_width()/2, (int)pos.y - sprite.get_height());
        end
    with
        every smallmap in e_DRAW_SMALLMAP do
            smallmap:draw_sprite(_deref(smallmap_symbol), _toVector3f(pos));
        end
    with
        every e_UPDATE do
            sprite.update();

            loop pingu in global:world:get_pingus():all_pingus do
                // Make sure this particular exit is allowed for this pingu
                if pingu:get_owner() != owner_id then
                    continue;
                end

                // Now, make sure the pingu is within range
                if pingu:get_x() <= pos.x-1 or pingu:get_x() >= pos.x+1 or
                   pingu:get_y() <= pos.y-5 or pingu:get_y() >= pos.y+5 then
                    continue;
                end

                // Now, make sure the pingu isn't already exiting, gone, or dead [or is dying because of apocalypse/bomber action]
                if pingu:get_current_action() != _A_EXITER and pingu:get_current_action() != _A_BOMBER and
                   pingu:get_current_action() != _A_DEAD and pingu:get_current_action() != _A_EXITED then
                    // Pingu actually exits
                    emit pingu:e_CHANGE_ACTION => _A_EXITER;
                end
            end
        end
    with
        await e_DELETE;
    end
end

#endif
