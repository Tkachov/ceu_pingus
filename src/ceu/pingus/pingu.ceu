#ifndef PINGU_CEU
#define PINGU_CEU

#include "../c.ceu"
#include "../sdl.ceu"
#include "actions/angelaction.ceu"
#include "actions/basheraction.ceu"
#include "actions/blockeraction.ceu"
#include "actions/boarderaction.ceu"
#include "actions/bomberaction.ceu"
#include "actions/bridgeraction.ceu"
#include "actions/climberaction.ceu"
#include "actions/diggeraction.ceu"
#include "actions/drownaction.ceu"
#include "actions/exiteraction.ceu"
#include "actions/falleraction.ceu"
#include "actions/floateraction.ceu"
#include "actions/jumperaction.ceu"
#include "actions/laserkillaction.ceu"
#include "actions/mineraction.ceu"
#include "actions/slideraction.ceu"
#include "actions/splashedaction.ceu"
#include "actions/supermanaction.ceu"
#include "actions/waiteraction.ceu"
#include "actions/walkeraction.ceu"
#include "iaction.ceu"
#include "ipingu.ceu"
#include "pingu_holder_listener.ceu"

native/pre do
    ##include "pingus/pingu.hpp"
    ##define A_Enum(x) (ActionName::Enum)(x)
    ##define delete_Pingu(p) delete p
    ##define RSA_Package Pingu::RequestSetActionPackage
    ##define PA_get_activation_mode(x) PinguAction::get_activation_mode(x)
    ##define PA_INSTANT ActionType::INSTANT
    ##define PA_WALL_TRIGGERED ActionType::WALL_TRIGGERED
    ##define PA_FALL_TRIGGERED ActionType::FALL_TRIGGERED
end

input _PinguAction* PINGU_SET_ACTION;
input void PINGU_UPDATE_ALL;
input _SceneContext* PINGU_DRAW_WALKER;
input _SceneContext* PINGU_DRAW_OTHERS;
input _Pingu* PINGU_DIE;
input _RSA_Package* PINGU_REQUEST_SET_ACTION;

native @pure _delete_Pingu(), _PA_get_activation_mode();

#define DO_ACTION(n, c) \
    else/if current_action == n then \
        current_action = do c with \
            this.pingu = outer; \
        end;

class Pingu with
    interface IPingu;
do
    function (int a) => _PinguAction* set_ptr do
        action = _PTR2REF(me.create_action2((ActionName_Enum)a));
        me.replace_action(action); //delete in there
        return action;
    end

    var _Pingu&? me_ = _PTR2REF((_Pingu*)&this.me);
    finalize with _delete_Pingu(me_); end

    var int previous_action = _A_FALLER;
    var int current_action = _A_FALLER;
    set_ptr(_A_FALLER);

    var int fall_action;
    var bool fall_action_set = false;
    var int wall_action;
    var bool wall_action_set = false;

    function (void) => bool has_fall_action do
        return fall_action_set;
    end

    function (void) => bool has_wall_action do
        return wall_action_set;
    end

    function (void) => int get_fall_action do
        return fall_action;
    end

    function (void) => int get_wall_action do
        return wall_action;
    end

    function (void) => int get_previous_action do
        return previous_action;
    end

    function (void) => _PinguAction* get_action do
        return action;
    end

    par do
        //pass update() call
        every PINGU_UPDATE_ALL do
            // original FIXME: Out of screen check is ugly
            // The Pingu has hit the edge of the screen, a good time to let him die.
            if me_.rel_getpixel(0, -1) == _GT_OUTOFSCREEN then
                //Sound::PingusSound::play_sound("die");
                emit e_CHANGE_ACTION => _A_DEAD;
            end

            emit e_UPDATE_CALLED;
        end
    with
        every p in PINGU_DIE do
            if p == &me_ then
               emit e_CHANGE_ACTION => _A_DEAD;
            end
        end
    with
        every gc in PINGU_DRAW_WALKER do
            if current_action == _A_WALKER then
                emit e_DRAW_CALLED => gc;
            end
        end
    with
        every gc in PINGU_DRAW_OTHERS do
            if current_action != _A_WALKER then
                emit e_DRAW_CALLED => gc;
            end
        end
    with
        //notify about set_action() call
        every a_ in PINGU_SET_ACTION do
            var _PinguAction&? a = _PTR2REF(a_);
            if a.pingu == &me_ then
                emit e_CHANGE_ACTION => a.get_type();
            end
        end
    with
        every p in PINGU_REQUEST_SET_ACTION do
            var _RSA_Package&? package = _PTR2REF(p);
            var _PinguAction&? paction = _PTR2REF(get_action()); //another no-"access across `await`"-hack

            if package.pingu != &me_ then
                continue;
            end;

            var int mode = _PA_get_activation_mode(package.action);

            if mode == _PA_INSTANT then
                if package.action == current_action then
                    _log_debug("Pingu: Already have action");
                else/if paction.change_allowed(_PTR2REF(package.action)) then
                    _log_debug("setting instant action");
                    package.result = true;
                    emit e_CHANGE_ACTION => package.action;
                else
                    _log_debug("change from action %1% not allowed", paction.get_name());
                end
            else/if mode == _PA_WALL_TRIGGERED then
                if wall_action_set and wall_action == package.action then
                    _log_debug("Not using wall action, we have already");
                else
                    _log_debug("Setting wall action");
                    wall_action = _PTR2REF(package.action);
                    wall_action_set = true;
                    package.result = true;
                end
            else/if mode == _PA_FALL_TRIGGERED then
                if fall_action_set and fall_action == package.action then
                    _log_debug("Not using fall action, we have already");
                else
                    _log_debug("Setting fall action");
                    fall_action = _PTR2REF(package.action);
                    fall_action_set = true;
                    package.result = true;
                end
            else
                _log_debug("unknown action activation_mode");
                _assert(0);
            end
        end
    with
        //wait for e_CHANGE_ACTION and create an instance
        var int last_action = current_action;
        loop do
            previous_action = last_action;
            last_action = current_action;
            watching current_action in e_CHANGE_ACTION do
                if false then
                    //this looks strange, but that macro is just an else/if block
                    DO_ACTION(_A_ANGEL, AngelAction)
                    DO_ACTION(_A_BASHER, BasherAction)
                    DO_ACTION(_A_BLOCKER, BlockerAction)
                    DO_ACTION(_A_BOARDER, BoarderAction)
                    DO_ACTION(_A_BOMBER, BomberAction)
                    DO_ACTION(_A_BRIDGER, BridgerAction)
                    DO_ACTION(_A_CLIMBER, ClimberAction)
                    DO_ACTION(_A_DIGGER, DiggerAction)
                    DO_ACTION(_A_DROWN, DrownAction)
                    DO_ACTION(_A_EXITER, ExiterAction)
                    DO_ACTION(_A_FALLER, FallerAction)
                    DO_ACTION(_A_FLOATER, FloaterAction)
                    DO_ACTION(_A_JUMPER, JumperAction)
                    DO_ACTION(_A_LASERKILL, LaserKillAction)
                    DO_ACTION(_A_MINER, MinerAction)
                    DO_ACTION(_A_SLIDER, SliderAction)
                    DO_ACTION(_A_SPLASHED, SplashedAction)
                    DO_ACTION(_A_SUPERMAN, SupermanAction)
                    DO_ACTION(_A_WAITER, WaiterAction)
                    DO_ACTION(_A_WALKER, WalkerAction)
                else/if current_action == _A_DEAD then
                    emit global:e_PINGU_DIED => &me;
                    escape 1;
                else/if current_action == _A_EXITED then
                    emit global:e_PINGU_EXITED => &me;
                    escape 2;
                else
                    await FOREVER;
                end

                await PINGU_UPDATE_ALL; //hack
            end
        end
    end
end

#endif
