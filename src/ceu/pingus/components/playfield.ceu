#ifndef PLAYFIELD_CEU
#define PLAYFIELD_CEU

#include "../../c.ceu"
#include "../../sdl.ceu"
#include "../../engine/gui/igui_component.ceu"
#include "../../math/vector2i.ceu"
#include "../../proxies/pointerproxy.ceu"
#include "../capture_rectangle.ceu"
#include "../pingu_holder_listener.ceu"
#include "../server.ceu"

native/pre do
    ##include "pingus/components/playfield.hpp"
    ##define send_pingu_action_event(playfield, pingu) playfield->server->send_pingu_action_event(pingu, playfield->session->get_action_name())
    ##define globals__developer_mode globals::developer_mode
    ##define const_Uint8 const Uint8
    ##define get_uint(u, v) u[v]
    ##define read_coords(vx, vy, fun) Vector2i __v = fun; vx = __v.x; vy = __v.y;
end

input _Playfield* PLAYFIELD_UPDATE;
input _Playfield* DELETE_PLAYFIELD;
input _SceneContext* PLAYFIELD_DRAW;
input _Vector2i* PLAYFIELD_CLICK;

native @pure _send_pingu_action_event(), _get_uint(), _read_coords();

class Playfield with
    interface IGUI_Component;
do
    var _Playfield&? playfield = _PTR2REF((_Playfield*)&me);

    playfield.state.set_limit(
        _Rect(
            _Vector2i(0, 0),
            _Size(global:world:get_width(), global:world:get_height())
        )
    );

    //original FIXME: Temporary workaround till start-pos is integrated a bit more properly
    playfield.state.set_pos(global:world:get_start_pos(0));

    var PointerProxy pp with
        this.gui = outer;
    end;
    var CaptureRectangle capture_rectangle with
        this.session = playfield.session;
    end;

    var IPingu* current_pingu = null;

    function @rec (int mx, int my) => IPingu* current_pingu_find do
        var float min_dist = 500.0;
        var float dist;
        var IPingu* c_pingu = null;

        loop pingu in global:world:get_pingus():all_pingus do
            if call/rec pingu:is_over(mx, my) then
                dist = call/rec pingu:dist(mx, my);

                if dist < min_dist then
                    min_dist = dist;
                    c_pingu = pingu;
                end
            end
        end

        return c_pingu;
    end

    function @rec (void) => IPingu* current_pingu_find_mouse do
        var int mx = playfield.state.screen2world(playfield.mouse_pos).x;
        var int my = playfield.state.screen2world(playfield.mouse_pos).y;
        return call/rec current_pingu_find(mx, my);
    end

    function (void) => IPingu* get_current_pingu do
        return current_pingu;
    end

    par/or do
        every (x, y) in mouse_move do
            x = x - playfield.rect.left;
            y = y - playfield.rect.top;

            //original FIXME: useless stuff, but currently the controller doesn't have a state
            playfield.mouse_pos.x = x;
            playfield.mouse_pos.y = y;

            if _globals__developer_mode then
                // Some fun stuff that lets you draw directly on the level
                var _const_Uint8&? keystate;
                finalize keystate = _SDL_GetKeyboardState(null); with end;

                var int px;
                var int py;
                _read_coords(px, py, playfield.state.screen2world(playfield.mouse_pos) finalize with end);

                if _get_uint(keystate, _SDL_SCANCODE_DELETE) then
                    var _CollisionMask* mask = _new_CollisionMask("other/bash_radius_gfx");
                    global:world:remove(mask, px - mask:get_width()/2, py - mask:get_height()/2);
                    _delete_obj(mask);
                else/if _get_uint(keystate, _SDL_SCANCODE_INSERT) then
                    var _CollisionMask* mask = _new_CollisionMask("other/bash_radius_gfx");
                    global:world:put(mask, px - mask:get_width()/2, py - mask:get_height()/2, _GT_GROUND);
                    _delete_obj(mask);
                else/if _get_uint(keystate, _SDL_SCANCODE_HOME) then
                    var _CollisionMask* mask = _new_CollisionMask("other/bash_radius_gfx");
                    global:world:put(mask, px - mask:get_width()/2, py - mask:get_height()/2, _GT_BRIDGE);
                    _delete_obj(mask);
                end
            end
        end
    with
        every p in PLAYFIELD_UPDATE do
            if p != &playfield then
                continue;
            end

            //find a current pingu & pass it to capture rectangle
            current_pingu = _PTR2REF(call/rec current_pingu_find_mouse());
            call/rec capture_rectangle.set_pingu(current_pingu);
        end
    with
        every gc in PLAYFIELD_DRAW do
            call/rec capture_rectangle.set_pingu(get_current_pingu()); //another no-"access across `await`"-hack
            emit capture_rectangle.draw => gc;

            if global:world != null then
                emit global:world:e_DRAW => gc;
            end
        end
    with
        every pos in PLAYFIELD_CLICK do
            current_pingu = _PTR2REF(call/rec current_pingu_find(pos:x, pos:y));

            if current_pingu then
                var Server* server = (Server*)playfield.server:ceu_server;
                call/rec server:send_pingu_action_event(current_pingu, playfield.session:get_action_name());
            end
        end
    with
        var _Playfield* p = await DELETE_PLAYFIELD until (p == &playfield);
    end
end

#endif
