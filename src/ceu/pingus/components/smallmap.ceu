#ifndef SMALLMAP_CEU
#define SMALLMAP_CEU

#include "../../c.ceu"
#include "../../sdl.ceu"
#include "../../engine/gui/igui_component.ceu"
#include "../../proxies/pointerproxy.ceu"
#include "../iworld.ceu"
#include "../ipingu_holder.ceu"
#include "../pingu_holder_listener.ceu"
#include "ismallmap.ceu"

native/pre do
    ##include "pingus/components/smallmap.hpp"
    ##include "pingus/smallmap_image.hpp"
end

input _SmallMap* NEW_SMALLMAP;
input _SmallMap* DELETE_SMALLMAP;
input _SmallMap* SMALLMAP_DRAW;

class SmallMap with
    interface IGUI_Component;
    interface ISmallMap;
do
    var _SmallMap&? small_map = _PTR2REF((_SmallMap*)&me);

    var PointerProxy pp with this.gui = outer; end;
    var PrimaryButtonProxy pbp with this.gui = outer; end;

    function @rec (_Sprite* sprite, _Vector3f pos) => void draw_sprite do
        var float x = (float)(small_map.rect.left) + (pos.x * (float)(small_map.rect.get_width())  / (float)(global:world:get_width()));
        var float y = (float)(small_map.rect.top)  + (pos.y * (float)(small_map.rect.get_height()) / (float)(global:world:get_height()));
        small_map.gc_ptr:draw(_deref(sprite), _Vector3f(x, y));
    end

    par/or do
        every sm in SMALLMAP_DRAW do
            if sm != &small_map then
                continue;
            end

            var int ofx = small_map.playfield:get_pos().x;
            var int ofy = small_map.playfield:get_pos().y;
            var int view_rect_left = 0;
            var int view_rect_top = 0;
            var int view_rect_right = 0;
            var int view_rect_bottom = 0;

            if global:world:get_width() > small_map.gc_ptr:get_width() then
                var int rwidth = small_map.gc_ptr:get_width()  * small_map.rect.get_width()  / global:world:get_width();
                view_rect_left  = small_map.rect.left + (ofx * small_map.rect.get_width()  / global:world:get_width()) - rwidth/2;
                view_rect_right = view_rect_left + rwidth;
            else
                view_rect_left  = small_map.rect.left;
                view_rect_right = small_map.rect.left + small_map.rect.get_width();
            end

            if global:world:get_height() > small_map.gc_ptr:get_height() then
                var int rheight = small_map.gc_ptr:get_height() * small_map.rect.get_height() / global:world:get_height();
                view_rect_top    = small_map.rect.top + (ofy * small_map.rect.get_height() / global:world:get_height()) - rheight/2;
                view_rect_bottom = view_rect_top + rheight;
            else
                view_rect_top    = small_map.rect.top;
                view_rect_bottom = small_map.rect.top + small_map.rect.get_height();
            end

            small_map.gc_ptr:draw(small_map.image:get_surface(), _Vector2i(small_map.rect.left, small_map.rect.top) finalize with end);
            small_map.gc_ptr:draw_rect(_Rect(view_rect_left, view_rect_top, view_rect_right, view_rect_bottom), _Color(0, 255, 0));

            emit global:world:e_DRAW_SMALLMAP => &this;

            // Draw Pingus
            loop pingu in global:world:get_pingus():all_pingus do
                var int x = (float)small_map.rect.left + pingu:get_x()*(float)small_map.rect.get_width()/(float)global:world:get_width();
                var int y = (float)small_map.rect.top + pingu:get_y()*(float)small_map.rect.get_height()/(float)global:world:get_height();

                _gc_draw_line(small_map.gc_ptr, _Vector2i(x, y), _Vector2i(x, y-2), _Color(255, 255, 0));
            end
        end
    with
        every (x, y) in mouse_move do
            if small_map.scroll_mode then
                var int cx = (x - small_map.rect.left) * (int)(global:world:get_width()  / small_map.rect.get_width());
                var int cy = (y - small_map.rect.top) * (int)(global:world:get_height() / small_map.rect.get_height());

                small_map.playfield:set_viewpoint(cx, cy);
            end
        end
    with
        every (x, y) in mouse_press do
            small_map.scroll_mode = true;

            // set view to the given COs
            var int cx = (x - small_map.rect.left) * (int)(global:world:get_width()) / small_map.rect.get_width();
            var int cy = (y - small_map.rect.top) * (int)(global:world:get_height()) / small_map.rect.get_height();

            small_map.playfield:set_viewpoint(cx, cy);
        end
    with
        var _SmallMap* e = await DELETE_SMALLMAP until (e == &small_map);
    end
end

#endif
