#ifndef DEMO_SESSION_CEU
#define DEMO_SESSION_CEU

#include "../../c.ceu"
#include "../../sdl.ceu"
#include "../iworld.ceu"
#include "../global_interface.ceu"
#include "../components/pingus_counter.ceu"
#include "../components/playfield.ceu"
#include "../components/smallmap.ceu"
#include "../server.ceu"

native/pre do
    ##include "pingus/screens/demo_session.hpp"
    ##define new_GUI_Component() new GUI::Component()
    ##define new_RectComponent(r) new GUI::RectComponent(r)
    ##define new_Rect(v, s) new Rect(v, s)
    ##define new_SceneContext(rect) new SceneContext(rect)
    ##define new_GraphicContextState(w, h) new GraphicContextState(w, h)
    ##define new_Server(a, b) new Server(a, b)    
    ##define ScreenManager__instance() ScreenManager::instance()
    ##define addr(x) &x
end

native @pure _new_PingusCounter(), _new_GUI_Component(), _new_RectComponent(), 
             _new_Rect(), _new_SceneContext(), _new_GraphicContextState(),
             _new_Server(), _ScreenManager__instance(), _addr();

input _ComponentUpdatePackage* DEMO_SESSION_UPDATE_SERVER;
input _DemoSession* DEMO_SESSION_UPDATE;
input _DemoSession* DELETE_DEMO_SESSION;
input _Vector2i* DEMO_SESSION_ON_SCROLLER_MOVE;

input _GUIScreen* ON_ARMAGEDDON_PRESS;
input _GUIScreen* ON_ARMAGEDDON_RELEASE;
input _GUIScreen* ON_ESCAPE_PRESS;
input _GUIScreen* ON_ESCAPE_RELEASE;

#define GET_SERVER ((Server*)demo_session.server:ceu())

class DemoSession with
    var _DemoSession* me;
    event void update_demo;
do
    var _DemoSession&? demo_session = _PTR2REF((_DemoSession*)me);

    var Server server with
        this.me = _new_Server(demo_session.plf, false);
        demo_session.server = _PTR2REF(this.me);
    end;

    var PingusCounter pcounter with
        this.me = _new_GUI_Component();
        this.server = _PTR2REF(demo_session.server);
        demo_session.pcounter = &this.me;
    end;

    var Playfield playfield with
        var _Rect&? rect = _new_Rect(
                                _Vector2i(
                                    _Math__max((demo_session.size.width - global:world:get_width())/2, 0),
                                    _Math__max((demo_session.size.height - global:world:get_height())/2, 0)
                                ),
                                _Size(
                                    _Math__min(demo_session.size.width, global:world:get_width()),
                                    _Math__min(demo_session.size.height, global:world:get_height())
                                )
                            );

        demo_session.playfield = _new_RectComponent(_deref(rect));
        this.me = _PTR2REF(demo_session.playfield);
        this.scene_context = _new_SceneContext(_deref(rect));
        this.state = _new_GraphicContextState(rect.get_width(), rect.get_height());
        this.server = _PTR2REF(demo_session.server);
        this.session = null;

        _delete_obj(rect);
    end;

    var SmallMap small_map with
        this.rect = _PTR2REF(_new_RectComponent(_Rect(_Vector2i(5, demo_session.size.height - 105), _Size(175, 100))));
        this.me = _PTR2REF(this.rect);
        this.server = _PTR2REF(demo_session.server);
        this.playfield = demo_session.playfield;
        demo_session.small_map = &this.rect;
    end;

    par/or do
        every package in DEMO_SESSION_UPDATE_SERVER do
            if (_DemoSession*)package:component != &demo_session then
                continue;
            end

            if GET_SERVER:is_finished() then
                _ScreenManager__instance():pop_screen();
            else
                //original FIXME: Duplicate all timing code here?!
                if not demo_session.pause then
                    if demo_session.fast_forward then
                        loop i in 4 do
                            demo_session.server:update();
                            emit update_demo;
                        end
                    else
                        emit GET_SERVER:e_UPDATE;
                        emit update_demo;
                    end
                end
            end
        end
    with
        every update_demo do
            loop do
                if demo_session.events.empty() or demo_session.events.back().time_stamp != call/rec GET_SERVER:get_time() then
                    break;
                end

                emit GET_SERVER:e_EVENT_SEND => _addr(demo_session.events.back());
                demo_session.events.pop_back();
            end

            // Check for unexpected things (might happen if the demo file is broken)
            if not demo_session.events.empty() and demo_session.events.back().time_stamp < call/rec GET_SERVER:get_time() then
                _log_info("DemoPlayer Bug: We missed a timestamp: %1%", demo_session.events.back().time_stamp);
            end
        end
    with
        every s in DEMO_SESSION_UPDATE do
            if s != &demo_session then
                continue;
            end
        end
    with
        every screen in ON_ESCAPE_PRESS do
            if screen == &demo_session then
                _log_info("Escape Pressed");
                emit server.e_FINISH_EVENT;
                _ScreenManager__instance():pop_screen();
            end
        end
    with
        every pos in DEMO_SESSION_ON_SCROLLER_MOVE do
            //original FIXME: Rounding considered evil?
            playfield.scroll(-pos:x, -pos:y);
            //well, I think it isn't
        end
    with
        var _DemoSession* e = await DELETE_DEMO_SESSION until (e == &demo_session);
        emit server.e_DELETE;
    end
end

#endif
