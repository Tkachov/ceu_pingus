#ifndef DEMO_SESSION_CEU
#define DEMO_SESSION_CEU

#include "../../c.ceu"
#include "../../sdl.ceu"
#include "../../engine/screen/screen.ceu"
#include "../iworld.ceu"
#include "../global_interface.ceu"
#include "../components/button_panel.ceu"
#include "../components/pingus_counter.ceu"
#include "../components/playfield.ceu"
#include "../components/smallmap.ceu"
#include "../server.ceu"

native/pre do
    ##include "pingus/screens/demo_session.hpp"
    ##include "engine/gui/gui_manager.hpp"
    ##include "engine/gui/surface_button.hpp"
    ##include "engine/screen/screen_manager.hpp"
    ##include "pingus/pingus_demo.hpp"
    ##include "pingus/server.hpp"
    ##include "util/ceu_utils.h"
    ##include "util/log.hpp"
    ##define new_GUI_Component() new GUI::Component()
    ##define new_RectComponent(r) new GUI::RectComponent(r)
    ##define new_Rect(v, s) new Rect(v, s)
    ##define new_SceneContext(rect) new SceneContext(rect)
    ##define new_GraphicContextState new GraphicContextState
    ##define new_Server(a) new Server(a)    
    ##define ScreenManager__instance() ScreenManager::instance()
end

native @pure _new_PingusCounter(), _new_GUI_Component(), _new_RectComponent(), 
             _new_Rect(), _new_SceneContext(), _new_GraphicContextState(),
             _new_Server(), _ScreenManager__instance(), _addr();

input _ComponentUpdatePackage* DEMO_SESSION_UPDATE_SERVER;
input _DemoSession* DEMO_SESSION_UPDATE;
input _DemoSession* DELETE_DEMO_SESSION;
input _Vector2i* DEMO_SESSION_ON_SCROLLER_MOVE;

class DemoSession with
    interface Screen;
    event void update_demo;
do
    var _DemoSession&? demo_session = (_DemoSession*)&me;

    var ScreenFramework sf with
        this.screen = outer;
    end;

    var Server server with
        this.me = _new_Server(demo_session.plf);
        demo_session.server = _PTR2REF(this.me);
    end;

    var PingusCounter pcounter with
        this.me = _new_GUI_Component();
        this.server = server;
    end;

    var Playfield playfield with
        var _Rect&? rect = _new_Rect(
                                _Vector2i(
                                    _Math__max((demo_session.size.width - global:world:get_width())/2, 0),
                                    _Math__max((demo_session.size.height - global:world:get_height())/2, 0)
                                ),
                                _Size(
                                    _Math__min(demo_session.size.width, global:world:get_width()),
                                    _Math__min(demo_session.size.height, global:world:get_height())
                                )
                            );
        
        this.me = _new_RectComponent(_deref(rect));
        this.scene_context = _new_SceneContext(_deref(rect));
        this.state = _new_GraphicContextState(rect.get_width(), rect.get_height());
        this.server = server;
        this.session = null;

        _delete_obj(rect);
    end;

    var SmallMap small_map with
        this.rect = _new_RectComponent(_Rect(_Vector2i(5, demo_session.size.height - 105), _Size(175, 100)));
        this.me = _PTR2REF(this.rect);        
        this.playfield = playfield;
    end;

    var ButtonPanel button_panel with
        this.me = _new_RectComponent(_Rect());
        this.server = server;
    end;

    do
        var Vector2i bp_pos;
        bp_pos.x = 0;
        bp_pos.y = (demo_session.size.height - 100)/2;
        button_panel.set_pos(bp_pos);
    end

    demo_session.gui_manager:add(&pcounter.me) finalize with end;
    demo_session.gui_manager:add(&button_panel.me) finalize with end;
    demo_session.gui_manager:add(&playfield.me) finalize with end;
    demo_session.gui_manager:add(&small_map.rect) finalize with end;

    par/or do
        every delta in global:update do
            if call/rec server.is_finished() then
                _ScreenManager__instance():pop_screen();
            else
                //original FIXME: Duplicate all timing code here?!
                if not demo_session.pause then
                    if demo_session.fast_forward then
                        loop i in 4 do
                            emit update_demo;
                            { ceu_utils::async_emit(CEU_IN_SERVER_UPDATE); };
                        end
                    else
                        emit update_demo;
                        { ceu_utils::async_emit(CEU_IN_SERVER_UPDATE); };
                    end
                end
            end
        end
    with
        every update_demo do
            loop do
                if demo_session.events.empty() or demo_session.events.back().time_stamp != call/rec server.get_time() then
                    break;
                end

                emit server.e_EVENT_SEND => _addr(demo_session.events.back());
                demo_session.events.pop_back();
            end

            // Check for unexpected things (might happen if the demo file is broken)
            if not demo_session.events.empty() and demo_session.events.back().time_stamp < call/rec server.get_time() then
                _log_info("DemoPlayer Bug: We missed a timestamp: %1%", demo_session.events.back().time_stamp);
            end
        end
    with
        every gc in draw_background do
            var _GUI_RectComponent* rect = (_GUI_RectComponent*)&playfield.me;

            if rect:get_rect() != _Rect(_Vector2i(0,0), _Size(gc:get_width(), gc:get_height())) then
                // Draw a black border around the playfield when the playfield is smaller then the screen                
                // top
                gc:draw_fillrect(_Rect(0, 0, gc:get_width(), rect:get_rect().top), _Color(0, 0, 0));
                // bottom
                gc:draw_fillrect(_Rect(0, rect:get_rect().bottom, gc:get_width(), gc:get_height()), _Color(0, 0, 0));
                // left
                gc:draw_fillrect(_Rect(0, rect:get_rect().top, rect:get_rect().left, rect:get_rect().bottom), _Color(0, 0, 0));
                // right
                gc:draw_fillrect(_Rect(rect:get_rect().right, rect:get_rect().top, gc:get_width(), rect:get_rect().bottom), _Color(0, 0, 0));
            end
        end 
    with
        every on_escape_press do            
            _log_info("Escape Pressed");
            emit server.e_FINISH_EVENT;
            _ScreenManager__instance():pop_screen();            
        end
    with
        every pos in DEMO_SESSION_ON_SCROLLER_MOVE do
            //original FIXME: Rounding considered evil?
            playfield.scroll(-pos:x, -pos:y);
            //well, I think it isn't
        end
    with
        every package in SCREEN_RESIZE do
            if package:screen != &demo_session then
                continue;
            end

            ((_GUI_RectComponent*)&playfield.me):set_rect(
                _Rect(
                    _Vector2i(
                        _Math__max((demo_session.size.width  - global:world:get_width())/2,  0),
                        _Math__max((demo_session.size.height - global:world:get_height())/2, 0)
                    ), 
                    _Size(
                        _Math__min(demo_session.size.width,  global:world:get_width()),
                        _Math__min(demo_session.size.height, global:world:get_height())
                    )
                )
            );

            demo_session.fastforward_button:set_pos(32+50, 32);
            demo_session.pause_button:set_pos(32, 32);
            demo_session.restart_button:set_pos(demo_session.size.width - 32 - 48, 32);

            small_map.rect.set_rect(_Rect(_Vector2i(5, demo_session.size.height - 105), _Size(175, 100)));
        end
    with
        var _DemoSession* e = await DELETE_DEMO_SESSION until (e == &demo_session);
        emit server.e_DELETE;
    end
end

#endif
