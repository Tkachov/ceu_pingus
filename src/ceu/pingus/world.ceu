#ifndef WORLD_CEU
#define WORLD_CEU

#include "../c.ceu"
#include "../sdl.ceu"
#include "iworld.ceu"
#include "pingu.ceu"
#include "pingu_holder.ceu"
#include "ground_map.ceu"
#include "particles/pingu_particles_holder.ceu"
#include "particles/rain_particles_holder.ceu"
#include "particles/smoke_particles_holder.ceu"
#include "particles/snow_particles_holder.ceu"
#include "worldobjs/conveyor_belt.ceu"
#include "worldobjs/entrance.ceu"
#include "worldobjs/exit.ceu"
#include "worldobjs/fake_exit.ceu"
#include "worldobjs/groundpiece.ceu"
#include "worldobjs/guillotine.ceu"
#include "worldobjs/hammer.ceu"
#include "worldobjs/hotspot.ceu"
#include "worldobjs/ice_block.ceu"
#include "worldobjs/laser_exit.ceu"
#include "worldobjs/liquid.ceu"
#include "worldobjs/rain_generator.ceu"
#include "worldobjs/smasher.ceu"
#include "worldobjs/snow_generator.ceu"
#include "worldobjs/solid_color_background.ceu"
#include "worldobjs/spike.ceu"
#include "worldobjs/starfield_background.ceu"
#include "worldobjs/surface_background.ceu"
#include "worldobjs/switch_door_door.ceu"
#include "worldobjs/switch_door_switch.ceu"
#include "worldobjs/teleporter.ceu"
#include "worldobjs/teleporter_target.ceu"

input IWorldObj* WORLD_DELETE_OBJECT;

input _World* DELETE_WORLD;
input _WOCPackage* NEW_CONVEYOR_BELT;
input _WOCPackage* NEW_ENTRANCE;
input _WOCPackage* NEW_EXIT;
input _WOCPackage* NEW_FAKE_EXIT;
input _WOCPackage* NEW_GROUNDPIECE;
input _WOCPackage* NEW_GUILLOTINE;
input _WOCPackage* NEW_HAMMER;
input _WOCPackage* NEW_HOTSPOT;
input _WOCPackage* NEW_ICE_BLOCK;
input _WOCPackage* NEW_LASER_EXIT;
input _WOCPackage* NEW_LIQUID;
input _WOCPackage* NEW_RAIN_GENERATOR;
input _WOCPackage* NEW_SMASHER;
input _WOCPackage* NEW_SNOW_GENERATOR;
input _WOCPackage* NEW_SOLID_COLOR_BACKGROUND;
input _WOCPackage* NEW_SPIKE;
input _WOCPackage* NEW_STARFIELD_BACKGROUND;
input _WOCPackage* NEW_SURFACE_BACKGROUND;
input _WOCPackage* NEW_SWITCH_DOOR_DOOR;
input _WOCPackage* NEW_SWITCH_DOOR_SWITCH;
input _WOCPackage* NEW_TELEPORTER;
input _WOCPackage* NEW_TELEPORTER_TARGET;

input _GetStartPosPackage* WORLD_GET_START_POS;

native/pre do
    ##define reader_read_Groundtype(r, s, v) r->read_enum(s, v, &Groundtype::string_to_type);

    ##include "pingus/resource.hpp"
    ##define Resource__load_surface Resource::load_surface

    ##define opeq(x, y) *x = y
    ##define new_Surface() new Surface()

    ##include "util/container.h"
    ##define new_Container() new Container()
end

native @pure _reader_read_Groundtype(), _Resource__load_surface(), _opeq(), _new_Surface(), _new_Container();

input _World* WORLD_STARTUP;
input _WorldDrawPackage* WORLD_DRAW;
input IWorldObj* WORLD_STARTUP_OBJECT;
input IWorldObj* WORLD_DRAW_OBJECT;

class World with
    interface IWorld;
    var _World& me;
    pool Entrance[] entrances;
    pool ITeleporterTarget[] teleporter_targets;
    pool ISwitchDoorDoor[] switch_door_doors;
do
    var _World&? me_ = _PTR2REF((_World*)&this.me);
    var _Container&? objs = _PTR2REF(_new_Container());
    finalize with _delete_obj(objs); end

    function (IWorldObj* o) => void add_object do
        objs.add((void*)o, o:me:get_z_pos());
        objs.sort();
    end

    var PinguHolder holder with
        this.me = _new_WorldObj();
        this.me:world = &me_;
        me_.world_obj.push_back(_PTR2REF(this.me));

        this.holder = me_.pingus;

        this.me:pos.z = 50; //TODO: somehow guarantee that it always stays that way
    end;

    var PinguParticlesHolder pingu_particles_holder with
        this.me = _new_WorldObj();
        this.me:world = &me_;
        me_.world_obj.push_back(_PTR2REF(this.me));

        this.sprite = _PTR2REF(_new_SpriteA("particles/pingu_explo"));
        this.particles = _PTR2REF(_new_Vector_PinguParticle());

        this.me:pos.z = 1000; //TODO: somehow guarantee that it always stays that way
    end;

    var RainParticlesHolder rain_particles_holder with
        this.me = _new_WorldObj();
        this.me:world = &me_;
        me_.world_obj.push_back(_PTR2REF(this.me));

        this.rain1_surf = _PTR2REF(_new_SpriteA("particles/rain1"));
        this.rain2_surf = _PTR2REF(_new_SpriteA("particles/rain2"));
        this.rain_splash = _PTR2REF(_new_SpriteA("particles/rain_splash"));
        this.particles = _PTR2REF(_new_Vector_RainParticle());

        this.me:pos.z = 1000; //TODO: somehow guarantee that it always stays that way
    end;

    var SmokeParticlesHolder smoke_particles_holder with
        this.me = _new_WorldObj();
        this.me:world = &me_;
        me_.world_obj.push_back(_PTR2REF(this.me));

        this.surf1 = _PTR2REF(_new_SpriteA("particles/smoke"));
        this.surf2 = _PTR2REF(_new_SpriteA("particles/smoke2"));
        this.particles = _PTR2REF(_new_Vector_SmokeParticle());

        this.me:pos.z = 1000; //TODO: somehow guarantee that it always stays that way
    end;

    var SnowParticlesHolder snow_particles_holder with
        this.me = _new_WorldObj();
        this.me:world = &me_;
        me_.world_obj.push_back(_PTR2REF(this.me));

        this.snow1 = _PTR2REF(_new_SpriteA("particles/snow1"));
        this.snow2 = _PTR2REF(_new_SpriteA("particles/snow2"));
        this.snow3 = _PTR2REF(_new_SpriteA("particles/snow3"));
        this.snow4 = _PTR2REF(_new_SpriteA("particles/snow4"));
        this.snow5 = _PTR2REF(_new_SpriteA("particles/snow5"));
        this.ground = _PTR2REF(_new_CollisionMask("particles/ground_snow"));
        this.particles = _PTR2REF(_new_Vector_SnowParticle());

        this.me:pos.z = 1000; //TODO: somehow guarantee that it always stays that way
    end;

    var GroundMap gfx_map with
        this.me = _new_WorldObj();
        this.me:world = &me_;

        this.gmap = _PTR2REF(_new_GroundMap(me_.mwidth, me_.mheight));

        this.me:pos.z = 0; //TODO: somehow guarantee that it always stays that way
        me_.gfx_map = _PTR2REF(this.gmap);
        me_.colmap = _PTR2REF(this.gmap.colmap.get());
        me_.world_obj.push_back(_PTR2REF(this.me));
    end;

    function (void) => IPinguHolder* get_pingus do
        return holder;
    end

    function (void) => IPinguParticlesHolder* get_pingu_particles_holder do
        return pingu_particles_holder;
    end

    function (void) => IRainParticlesHolder* get_rain_particles_holder do
        return rain_particles_holder;
    end

    function (void) => ISmokeParticlesHolder* get_smoke_particles_holder do
        return smoke_particles_holder;
    end

    function (void) => ISnowParticlesHolder* get_snow_particles_holder do
        return snow_particles_holder;
    end

    function (_const_char_string id) => ITeleporterTarget* get_teleporter_target do
        loop target in teleporter_targets do
            if target:me:id == id then
                return target;
            end
        end

        return null;
    end

    function (_const_char_string id) => ISwitchDoorDoor* get_switch_door_door do
        loop door in switch_door_doors do
            if door:me:id == id then
                return door;
            end
        end

        return null;
    end

    var bool draw_iterating = false;
    var _SceneContext* gc = null;

    par/or do
        every w in WORLD_STARTUP do
            if w != &me_ then
                continue;
            end

            objs.iterate(_CEU_IN_WORLD_STARTUP_OBJECT);
        end
    with
        every object in WORLD_STARTUP_OBJECT do            
            emit object:e_STARTUP;
        end
    with
        every package in WORLD_DRAW do
            draw_iterating = true;
            gc = _PTR2REF(package:gc);            
            objs.iterate(_CEU_IN_WORLD_DRAW_OBJECT);            
            draw_iterating = false;
            gc = null;
        end
    with
        every object in WORLD_DRAW_OBJECT do            
            if draw_iterating and gc != null then                
                emit object:e_DRAW => gc;
            end
        end
    with
        every w in WORLD_UPDATE do
            if w != &me_ then
                continue;
            end

            if me_.do_armageddon and me_.game_time%4 == 0 then
                loop pingu in holder.all_pingus do
                    if pingu:get_current_action() == _A_BOMBER or pingu:get_current_action() == _A_DROWN or
                       pingu:get_current_action() == _A_SPLASHED or pingu:get_current_action() == _A_LASERKILL or
                       pingu:get_current_action() == _A_DEAD or pingu:get_current_action() == _A_EXITED then
                        continue;
                    end

                    emit pingu:e_CHANGE_ACTION => _A_BOMBER;
                    break;
                end
            end
        end
    with
        every package in WORLD_GET_START_POS do
            if package:world != &me_ then
                continue;
            end

            var int num_entrances = 0;

            loop entrance in entrances do
                if entrance:owner_id == package:player_id then
                    package:pos.x = package:pos.x + entrance:me:get_pos().x;
                    package:pos.y = package:pos.y + entrance:me:get_pos().y;
                    num_entrances = num_entrances + 1;
                end
            end

            if num_entrances>0 then
                package:pos.x = package:pos.x/num_entrances;
                package:pos.y = package:pos.y/num_entrances;
                package:pos.y = package:pos.y+100;
            end
        end
    with
        every package in NEW_CONVEYOR_BELT do
            spawn ConveyorBelt with
                this.me = _new_WorldObj();
                package:result = this.me;

                this.left_sur = _PTR2REF(_new_SpriteA("worldobjs/conveyorbelt_left"));
                this.right_sur = _PTR2REF(_new_SpriteA("worldobjs/conveyorbelt_right"));
                this.middle_sur = _PTR2REF(_new_SpriteA("worldobjs/conveyorbelt_middle"));

                package:reader:read_vector("position", _PTR2REF(this.me:pos));
                if not package:reader:read_int("repeat", _PTR2REF(this.width)) then
                    _log_warn("old 'width' tag used");
                    package:reader:read_int("width", _PTR2REF(this.width));
                end
                package:reader:read_float("speed", _PTR2REF(this.speed));
            end;
        end
    with
        every package in NEW_ENTRANCE do
            spawn Entrance in entrances with
                this.me = _new_WorldObj();
                package:result = this.me;

                this.direction = ED_MISC;
                this.release_rate = 150;
                this.owner_id = 0;
                this.smallmap_symbol = _PTR2REF(_new_SpriteA("core/misc/smallmap_entrance"));
                this.surface = _PTR2REF(_new_Sprite());

                package:reader:read_int("owner-id", _PTR2REF(this.owner_id));
                package:reader:read_vector("position", _PTR2REF(this.me:pos));
                package:reader:read_int("release-rate",  _PTR2REF(this.release_rate));

                // Set default owner ID to 0
                if this.owner_id<0 or this.owner_id>3 then
                    this.owner_id = 0;
                end

                var _String&? direction_str = _PTR2REF(_new_String());
                _string_read_string(direction_str, package:reader, "direction");

                if direction_str == "left" then
                    this.direction = ED_LEFT;
                else/if direction_str == "right" then
                    this.direction = ED_RIGHT;
                else/if direction_str == "misc" then
                    this.direction = ED_MISC;
                else
                    _log_error("unknown direction: '%1%'", direction_str);
                    this.direction = ED_MISC;
                end

                _delete_obj(direction_str);
            end;
        end;
    with
        every package in NEW_EXIT do
            spawn Exit with
                this.me = _new_WorldObj();
                package:result = this.me;

                this.desc = _PTR2REF(_new_ResDescriptor());
                this.smallmap_symbol = _PTR2REF(_new_SpriteA("core/misc/smallmap_exit"));

                package:reader:read_vector("position", _PTR2REF(this.me:pos));
                package:reader:read_desc  ("surface",  _deref(this.desc));
                package:reader:read_int   ("owner-id", _PTR2REF(this.owner_id));

                // Set default owner ID to 0
                if this.owner_id<0 or this.owner_id>3 then
                    this.owner_id = 0;
                end

                this.flag = _PTR2REF(_new_SpriteA(_scc2("core/misc/flag", _StringUtil__to_string(this.owner_id))));
                this.sprite = _PTR2REF(_new_SpriteA(_deref(this.desc)));
            end;
        end
    with
        every package in NEW_FAKE_EXIT do
            spawn FakeExit with
                this.me = _new_WorldObj();
                package:result = this.me;

                this.sprite = _PTR2REF(_new_SpriteA("traps/fake_exit"));
                this.smallmap_symbol = _PTR2REF(_new_SpriteA("core/misc/smallmap_exit"));
                this.smashing = false;

                package:reader:read_vector("position", _PTR2REF(this.me:pos));
                this.me:pos.x = this.me:pos.x - (float)this.sprite.get_width()/2;
                this.me:pos.y = this.me:pos.y - (float)this.sprite.get_height();
            end;
        end
    with
        every package in NEW_GROUNDPIECE do
            spawn Groundpiece with
                this.me = _new_WorldObj();
                package:result = this.me;

                package:reader:read_vector("position", _PTR2REF(this.me:pos));
                this.desc = _PTR2REF(_new_ResDescriptor());
                package:reader:read_desc("surface", _deref(this.desc));
                this.gptype = _GT_GROUND;
                _reader_read_Groundtype(package:reader, "type", _PTR2REF(this.gptype));
            end;
        end
    with
        every package in NEW_GUILLOTINE do
            spawn Guillotine with
                this.me = _new_WorldObj();
                package:result = this.me;

                this.sprite_kill_right = _PTR2REF(_new_SpriteA("traps/guillotinekill/right"));
                this.sprite_kill_left = _PTR2REF(_new_SpriteA("traps/guillotinekill/left"));
                this.sprite_idle = _PTR2REF(_new_SpriteA("traps/guillotineidle"));
                this.direction = _new_Direction();
                this.killing = false;

                package:reader:read_vector("position", _PTR2REF(this.me:pos));
                this.sprite_kill_right.set_play_loop(false);
                this.sprite_kill_left.set_play_loop(false);
                this.sprite_idle.set_play_loop(true);
            end;
        end
    with
        every package in NEW_HAMMER do
            spawn Hammer with
                this.me = _new_WorldObj();
                package:result = this.me;

                this.sprite = _PTR2REF(_new_SpriteA("traps/hammer"));
                package:reader:read_vector("position", _PTR2REF(this.me:pos));
            end;
        end
    with
        every package in NEW_HOTSPOT do
            spawn Hotspot with
                this.me = _new_WorldObj();
                package:result = this.me;

                var _ResDescriptor&? desc = _PTR2REF(_new_ResDescriptor());

                package:reader:read_vector("position", _PTR2REF(this.me:pos));
                package:reader:read_desc  ("surface",  _deref(desc));
                package:reader:read_float ("parallax", _PTR2REF(this.para));

                this.sprite = _PTR2REF(_new_SpriteA(_deref(desc)));

                _delete_obj(desc);
            end;
        end
    with
        every package in NEW_ICE_BLOCK do
            spawn IceBlock with
                this.me = _new_WorldObj();
                package:result = this.me;

                this.block_sur = _PTR2REF(_new_SpriteA("worldobjs/iceblock"));
                this.block_sur_cmap = _PTR2REF(_new_CollisionMask("worldobjs/iceblock_cmap"));

                package:reader:read_vector("position", _PTR2REF(this.me:pos));
                if not package:reader:read_int("repeat", _PTR2REF(this.width)) then
                    _log_warn("old 'width' tag used");
                    package:reader:read_int("width", _PTR2REF(this.width));
                end
            end;
        end
    with
        every package in NEW_LASER_EXIT do
            spawn LaserExit with
                this.me = _new_WorldObj();
                package:result = this.me;

                this.surface = _PTR2REF(_new_SpriteA("traps/laser_exit"));
                package:reader:read_vector("position", _PTR2REF(this.me:pos));
            end;
        end
    with
        every package in NEW_LIQUID do
            spawn Liquid with
                this.me = _new_WorldObj();
                package:result = this.me;

                this.width = 0;

                var _ResDescriptor&? desc = _PTR2REF(_new_ResDescriptor());

                package:reader:read_vector("position", _PTR2REF(this.me:pos));
                package:reader:read_desc  ("surface",  _deref(desc));
                package:reader:read_int   ("repeat",   _PTR2REF(this.width));

                this.sprite = _PTR2REF(_new_SpriteA(_deref(desc)));
            end;
        end
    with
        every package in NEW_RAIN_GENERATOR do
            spawn RainGenerator with
                this.me = _new_WorldObj();
                package:result = this.me;

                this.me:pos.z = 1000; //TODO: somehow guarantee that it always stays that way
            end;
        end
    with
        every package in NEW_SMASHER do
            spawn Smasher with
                this.me = _new_WorldObj();
                package:result = this.me;

                this.sprite = _PTR2REF(_new_SpriteA("traps/smasher"));
                package:reader:read_vector("position", _PTR2REF(this.me:pos));
                _assert(this.sprite.get_frame_count() == 6);
            end;
        end
    with
        every package in NEW_SNOW_GENERATOR do
            spawn SnowGenerator with
                this.me = _new_WorldObj();
                package:result = this.me;

                this.intensity = 1;
                package:reader:read_float("intensity", _PTR2REF(this.intensity));
                this.me:pos.z = 1000; //TODO: somehow guarantee that it always stays that way
            end;
        end
    with
        every package in NEW_SOLID_COLOR_BACKGROUND do
            spawn SolidColorBackground with
                this.me = _new_WorldObj();
                package:result = this.me;

                this.color = _PTR2REF(_new_Color());
                if not package:reader:read_colori("colori", _deref(this.color)) then
                    package:reader:read_colorf("color", _deref(this.color));
                end
                this.me:pos.z = -10; //TODO: somehow guarantee that it always stays that way
            end;
        end
    with
        every package in NEW_SPIKE do
            spawn Spike with
                this.me = _new_WorldObj();
                package:result = this.me;

                this.surface = _PTR2REF(_new_SpriteA("traps/spike"));
                package:reader:read_vector("position", _PTR2REF(this.me:pos));
            end;
        end
    with
        every package in NEW_STARFIELD_BACKGROUND do
            spawn StarfieldBackground with
                this.me = _new_WorldObj();
                package:result = this.me;

                this.small_stars_count = 100;
                this.middle_stars_count = 50;
                this.large_stars_count = 25;

                package:reader:read_int("small-stars", _PTR2REF(this.small_stars_count));
                package:reader:read_int("middle-stars", _PTR2REF(this.middle_stars_count));
                package:reader:read_int("large-stars", _PTR2REF(this.large_stars_count));

                //original FIXME: Make z_pos handling editable via xml
                this.me:pos.z = -10; //TODO: somehow guarantee that it always stays that way
            end;
        end
    with
        every package in NEW_SURFACE_BACKGROUND do
            spawn SurfaceBackground with
                this.me = _new_WorldObj();
                package:result = this.me;

                this.para_x = 0.5;
                this.para_y = 0.5;
                this.scroll_x = 0;
                this.scroll_y = 0;
                this.color = _PTR2REF(_new_Color(0, 0, 0, 0));
                this.stretch_x = false;
                this.stretch_y = false;
                this.keep_aspect = false;
                this.scroll_ox = 0;
                this.scroll_oy = 0;

                if not package:reader:read_vector("position", _PTR2REF(this.me:pos)) then
                    this.me:pos.x = 0;
                    this.me:pos.y = 0;
                    this.me:pos.z = -150;
                end

                var _ResDescriptor&? desc = _PTR2REF(_new_ResDescriptor());
                package:reader:read_desc("surface",  _deref(desc));

                if not package:reader:read_colori("colori", _deref(this.color)) then
                    package:reader:read_colorf("color", _deref(this.color));
                end

                package:reader:read_float("para-x", _PTR2REF(this.para_x));
                package:reader:read_float("para-y", _PTR2REF(this.para_y));

                package:reader:read_float("scroll-x", _PTR2REF(this.scroll_x));
                package:reader:read_float("scroll-y", _PTR2REF(this.scroll_y));

                package:reader:read_bool("stretch-x", _PTR2REF(this.stretch_x));
                package:reader:read_bool("stretch-y", _PTR2REF(this.stretch_y));

                package:reader:read_bool("keep-aspect", _PTR2REF(this.keep_aspect));

                if not this.stretch_x and not this.stretch_y and this.color.a == 0 then
                    //orignal FIXME: would be nice to allow surface manipulation with
                    // animated sprites, but it's not that easy to do
                    this.sprite = _PTR2REF(_new_SpriteA(_deref(desc)));
                else
                    var _Surface&? surface = _new_Surface();
                    _opeq(surface, _Resource__load_surface(_deref(desc)));

                    if this.color.a != 0 and surface.is_indexed() then
                        if surface.has_colorkey() then
                            _opeq(surface, surface.convert_to_rgba());
                        else
                            _opeq(surface, surface.convert_to_rgb());
                        end
                    end

                    surface.fill(_deref(this.color));

                    // Scaling Code
                    if this.stretch_x and this.stretch_y then
                        _opeq(surface, surface.scale(this.me:world:get_width(), this.me:world:get_height()));
                    else/if this.stretch_x and not this.stretch_y then
                        if this.keep_aspect then
                            var float aspect = (float)surface.get_height() / (float)surface.get_width();
                            _opeq(surface, surface.scale(this.me:world:get_width(), (int)((float)this.me:world:get_width()*aspect)));
                        else
                            _opeq(surface, surface.scale(this.me:world:get_width(), surface.get_height()));
                        end
                    else/if not this.stretch_x and this.stretch_y then
                        if this.keep_aspect then
                            var float aspect = (float)surface.get_width() / (float)surface.get_height();
                            _opeq(surface, surface.scale((int)((float)this.me:world:get_height()*aspect), this.me:world:get_height()));
                        else
                            _opeq(surface, surface.scale(surface.get_width(), this.me:world:get_height()));
                        end
                    end

                    this.sprite = _PTR2REF(_new_SpriteA(_deref(surface)));
                end

                _delete_obj(desc);
            end;
        end
    with
        every package in NEW_SWITCH_DOOR_DOOR do
            spawn SwitchDoorDoor in switch_door_doors with
                this.me = _new_WorldObj();
                package:result = this.me;

                package:reader:read_string("id", _PTR2REF(this.me:id));

                this.door_box = _PTR2REF(_new_SpriteA("worldobjs/switchdoor_box"));
                this.door_box_cmap = _PTR2REF(_new_CollisionMask("worldobjs/switchdoor_box"));
                this.door_tile = _PTR2REF(_new_SpriteA("worldobjs/switchdoor_tile"));
                this.door_tile_cmap = _PTR2REF(_new_CollisionMask("worldobjs/switchdoor_tile_cmap"));
                this.is_opening = false;

                package:reader:read_vector("position", _PTR2REF(this.me:pos));
                this.me:pos.z = 100; //TODO: somehow guarantee that it always stays that way

                package:reader:read_int("height", _PTR2REF(this.door_height));
                this.current_door_height = this.door_height;
            end;
        end
    with
        every package in NEW_SWITCH_DOOR_SWITCH do
            spawn SwitchDoorSwitch with
                this.me = _new_WorldObj();
                package:result = this.me;

                this.switch_sur = _PTR2REF(_new_SpriteA("worldobjs/switchdoor_switch"));
                this.is_triggered = false;
                this.m_target = _PTR2REF(_new_String());
                _string_read_string(this.m_target, package:reader, "target-id");
                package:reader:read_vector("position", _PTR2REF(this.me:pos));
                this.me:pos.z = 100; //TODO: somehow guarantee that it always stays that way
            end;
        end
    with
        every package in NEW_TELEPORTER do
            spawn Teleporter with
                this.me = _new_WorldObj();
                package:result = this.me;

                this.sprite = _PTR2REF(_new_SpriteA("worldobjs/teleporter"));
                package:reader:read_vector("position", _PTR2REF(this.me:pos));
                this.target_id = _PTR2REF(_new_String());
                _string_read_string(this.target_id, package:reader, "target-id");
            end;
        end
    with
        every package in NEW_TELEPORTER_TARGET do
            spawn TeleporterTarget in teleporter_targets with
                this.me = _new_WorldObj();
                package:result = this.me;

                package:reader:read_string("id", _PTR2REF(this.me:id));
                this.sprite = _PTR2REF(_new_SpriteA("worldobjs/teleportertarget"));
                package:reader:read_vector("position", _PTR2REF(this.me:pos));
            end;
        end
    with
        every w in CLEAN_WORLD do
            if w != &me_ then
                continue;
            end
            
            objs.iterate(_CEU_IN_WORLD_DELETE_OBJECT);
        end
    with
        every object in WORLD_DELETE_OBJECT do            
            emit object:e_DELETE;
        end 
    with
        every w in DELETE_WORLD do
            if w == &me_ then
                break;
            end
        end
    end
end

#endif
