#ifndef WORLD_CEU
#define WORLD_CEU

#include "../c.ceu"
#include "../sdl.ceu"
#include "iworld.ceu"
#include "pingu.ceu"
#include "pingu_holder.ceu"
#include "ground_map.ceu"
#include "particles/pingu_particles_holder.ceu"
#include "particles/rain_particles_holder.ceu"
#include "particles/smoke_particles_holder.ceu"
#include "particles/snow_particles_holder.ceu"
#include "worldobjs/conveyor_belt.ceu"
#include "worldobjs/entrance.ceu"
#include "worldobjs/exit.ceu"
#include "worldobjs/fake_exit.ceu"
#include "worldobjs/groundpiece.ceu"
#include "worldobjs/guillotine.ceu"
#include "worldobjs/hammer.ceu"
#include "worldobjs/hotspot.ceu"
#include "worldobjs/ice_block.ceu"
#include "worldobjs/laser_exit.ceu"
#include "worldobjs/liquid.ceu"
#include "worldobjs/rain_generator.ceu"
#include "worldobjs/smasher.ceu"
#include "worldobjs/snow_generator.ceu"
#include "worldobjs/solid_color_background.ceu"
#include "worldobjs/spike.ceu"
#include "worldobjs/starfield_background.ceu"
#include "worldobjs/surface_background.ceu"
#include "worldobjs/switch_door_door.ceu"
#include "worldobjs/switch_door_switch.ceu"
#include "worldobjs/teleporter.ceu"
#include "worldobjs/teleporter_target.ceu"

input _WOCPackage* NEW_CONVEYOR_BELT;
input _WOCPackage* NEW_ENTRANCE;
input _WOCPackage* NEW_EXIT;
input _WOCPackage* NEW_FAKE_EXIT;
input _WOCPackage* NEW_GROUNDPIECE;
input _WOCPackage* NEW_GUILLOTINE;
input _WOCPackage* NEW_HAMMER;
input _WOCPackage* NEW_HOTSPOT;
input _WOCPackage* NEW_ICE_BLOCK;
input _WOCPackage* NEW_LASER_EXIT;
input _WOCPackage* NEW_LIQUID;
input _WOCPackage* NEW_RAIN_GENERATOR;
input _WOCPackage* NEW_SMASHER;
input _WOCPackage* NEW_SNOW_GENERATOR;
input _WOCPackage* NEW_SOLID_COLOR_BACKGROUND;
input _WOCPackage* NEW_SPIKE;
input _WOCPackage* NEW_STARFIELD_BACKGROUND;
input _WOCPackage* NEW_SURFACE_BACKGROUND;
input _WOCPackage* NEW_SWITCH_DOOR_DOOR;
input _WOCPackage* NEW_SWITCH_DOOR_SWITCH;
input _WOCPackage* NEW_TELEPORTER;
input _WOCPackage* NEW_TELEPORTER_TARGET;

input _PrefabPackage* PREFAB_POS;
input _WorldGetSizePackage* WORLD_GET_SIZE;

native/pre do
    ##define reader_read_Groundtype(r, s, v) r->read_enum(s, v, &Groundtype::string_to_type);

    ##include "pingus/resource.hpp"
    ##define Resource__load_surface Resource::load_surface

    ##define opeq(x, y) *x = y
    ##define new_Surface() new Surface()

    ##include "util/container.h"
    ##define new_Container() new Container()

    ##define read_position(r, p) Vector3f __v; r->read_vector("position", __v); p.x = __v.x; p.y = __v.y; p.z = __v.z;
    ##define read_position2(r, p, res) Vector3f __v; res = r->read_vector("position", __v); p.x = __v.x; p.y = __v.y; p.z = __v.z;

    ##define new_Color new Color
end

native @pure _reader_read_Groundtype(), _Resource__load_surface(), _opeq(), _new_Surface(), _new_Container(), _new_Color(),
             _read_position(), _read_position2();

input _World* WORLD_STARTUP;
input _World* WORLD_DELETE;

input IWorldObj* WORLD_STARTUP_OBJECT;
input IWorldObj* WORLD_DRAW_OBJECT;
input IWorldObj* WORLD_DRAW_SMALLMAP_OBJECT;
input IWorldObj* WORLD_UPDATE_OBJECT;
input IWorldObj* WORLD_DELETE_OBJECT;

class World with
    interface IWorld;
    pool Entrance[] entrances;
    pool ITeleporterTarget[] teleporter_targets;
    pool ISwitchDoorDoor[] switch_door_doors;
do
    var _World&? me = _PTR2REF((_World*)world);
    var _Container&? objs = _PTR2REF(_new_Container());
    finalize with _delete_obj(objs); end

    var bool do_armageddon = false;
    var int armageddon_count = 0;
    var int game_time = 0;
    var _Color&? ambient_light = _new_Color(me.pingus_level.get_ambient_light());
    finalize with _delete_obj(ambient_light); end

    function (void) => bool check_armageddon do
        return do_armageddon;
    end

    function (int player_id) => _Vector2i get_start_pos do
        //original FIXME: Workaround for lack of start-pos
        var int num_entrances = 0;
        var int px = 0;
        var int py = 0;

        loop entrance in entrances do
            if entrance:owner_id == player_id then
                px = px + entrance:get_pos().x;
                py = py + entrance:get_pos().y;
                num_entrances = num_entrances + 1;
            end
        end

        if num_entrances>0 then
            px = px/num_entrances;
            py = py/num_entrances + 100;
        end

        return _Vector2i(px, py);
    end

    function (void) => int get_width do
        return me.gfx_map:get_width();
    end

    function (void) => int get_height do
        return me.gfx_map:get_height();
    end

    function (void) => int get_time do
        return game_time;
    end

    function (_const_char_string name, Vector3f pos, float volume) => void play_sound do
        //original FIXME: Stereo is for the moment disabled
        /*
        Vector3f center = view->get_center();
        float panning = pos.x - center.x;
        panning /= view->get_width()/2;

        if (panning > 1.0f)
            panning = 1.0f;

        if (panning < -1.0f)
            panning = -1.0f;
        */
        var float panning = 0;
        _Sound_PingusSound_play_sound(name, volume, panning);
    end

    function @rec (IWorldObj* o) => void add_object do
        objs.add((void*)o, o:get_z_pos());
        objs.sort();
    end

    function (IWorldObj* o) => void remove_object do
        objs.remove((void*)o);
    end

    var PinguHolder holder with
        this.number_of_allowed = me.pingus_level.get_number_of_pingus();
    end;

    var PinguParticlesHolder pingu_particles_holder;
    var RainParticlesHolder rain_particles_holder;
    var SmokeParticlesHolder smoke_particles_holder;
    var SnowParticlesHolder snow_particles_holder;

    var GroundMap gfx_map with
        this.gmap = _PTR2REF(_new_GroundMap(me.pingus_level.get_size().width, me.pingus_level.get_size().height));

        me.gfx_map = _PTR2REF(this.gmap);
        me.colmap = _PTR2REF(this.gmap.colmap.get());
    end;

    function (void) => IPinguHolder* get_pingus do
        return holder;
    end

    function (void) => IPinguParticlesHolder* get_pingu_particles_holder do
        return pingu_particles_holder;
    end

    function (void) => IRainParticlesHolder* get_rain_particles_holder do
        return rain_particles_holder;
    end

    function (void) => ISmokeParticlesHolder* get_smoke_particles_holder do
        return smoke_particles_holder;
    end

    function (void) => ISnowParticlesHolder* get_snow_particles_holder do
        return snow_particles_holder;
    end

    function (_const_char_string id) => ITeleporterTarget* get_teleporter_target do
        loop target in teleporter_targets do
            if target:id == id then
                return target;
            end
        end

        return null;
    end

    function (_const_char_string id) => ISwitchDoorDoor* get_switch_door_door do
        loop door in switch_door_doors do
            if door:id == id then
                return door;
            end
        end

        return null;
    end

    function (_CollisionMask* mask, int x, int y, int type) => void put do
        world:gfx_map:put(mask:get_surface(), x, y);
        world:colmap:put(_deref(mask), x, y, _to_GT(type));
    end

    function (_CollisionMask* mask, int x, int y) => void remove do
        world:gfx_map:remove(mask:get_surface(), x, y);
        world:colmap:remove(_deref(mask), x, y);
    end

    function (_const_char_string str, int x, int y, int t) => void put_str do
        var _CollisionMask* mask = _new_CollisionMask(str);
        put(mask, x, y, t);
        _delete_obj(mask);
    end

    function (_const_char_string str, int x, int y) => void remove_str do
        var _CollisionMask* mask = _new_CollisionMask(str);
        remove(mask, x, y);
        _delete_obj(mask);
    end

    var bool draw_iterating = false;
    var _SceneContext* gc = null;

    par/or do
        every package in WORLD_GET_SIZE do
            if package:world != &me then
                continue;
            end

            package:width = get_width();
            package:height = get_height();
        end
    with
        every w in WORLD_STARTUP do
            if w != &me then
                continue;
            end

            objs.iterate(_CEU_IN_WORLD_STARTUP_OBJECT);
        end
    with
        every object in WORLD_STARTUP_OBJECT do
            emit object:e_STARTUP;
        end
    with
        every wgc in e_DRAW do
            wgc:light().fill_screen(_Color(_deref(ambient_light)));

            draw_iterating = true;
            gc = _PTR2REF(wgc);
            objs.iterate(_CEU_IN_WORLD_DRAW_OBJECT);
            draw_iterating = false;
            gc = null;
        end
    with
        every object in WORLD_DRAW_OBJECT do
            if draw_iterating and gc != null then
                emit object:e_DRAW => gc;
            end
        end
    with
        every smallmap in e_DRAW_SMALLMAP do
            loop i in objs.size() do
                emit ((IWorldObj*)objs.get(i)):e_DRAW_SMALLMAP => smallmap;
            end
        end
    with
        every e_UPDATE do
            game_time = game_time + 1;

            if do_armageddon and game_time%4 == 0 then
                loop pingu in holder.all_pingus do
                    if pingu:get_current_action() == _A_BOMBER or pingu:get_current_action() == _A_DROWN or
                       pingu:get_current_action() == _A_SPLASHED or pingu:get_current_action() == _A_LASERKILL or
                       pingu:get_current_action() == _A_DEAD or pingu:get_current_action() == _A_EXITED then
                        continue;
                    end

                    emit pingu:e_CHANGE_ACTION => _A_BOMBER;
                    break;
                end
            end

            objs.iterate(_CEU_IN_WORLD_UPDATE_OBJECT);
        end
    with
        every object in WORLD_UPDATE_OBJECT do
            emit object:e_UPDATE;
        end
    with
        every e_ARMAGEDDON do
            _Sound_PingusSound_play_sound("goodidea");
            do_armageddon = true;
            armageddon_count = 0;
        end
    with
        every p4ckage in PREFAB_POS do
            var IWorldObj* wobject = (IWorldObj*)p4ckage:object;
            //wobject:set_pos(wobject:get_pos() + p4ckage:pos);
            wobject:pos.x = wobject:pos.x + p4ckage:pos.x;
            wobject:pos.y = wobject:pos.y + p4ckage:pos.y;
            wobject:pos.z = wobject:pos.z + p4ckage:pos.z;
        end
    with
        every package in NEW_CONVEYOR_BELT do
            spawn ConveyorBelt with
                package:result = &this;

                _read_position(package:reader, this.pos);
                if not package:reader:read_int("repeat", _PTR2REF(this.width)) then
                    _log_warn("old 'width' tag used");
                    package:reader:read_int("width", _PTR2REF(this.width));
                end
                package:reader:read_float("speed", _PTR2REF(this.speed));
            end;
        end
    with
        every package in NEW_ENTRANCE do
            spawn Entrance in entrances with
                package:result = &this;

                this.direction = ED_MISC;
                this.release_rate = 150;
                this.owner_id = 0;

                package:reader:read_int("owner-id", _PTR2REF(this.owner_id));
                _read_position(package:reader, this.pos);
                package:reader:read_int("release-rate",  _PTR2REF(this.release_rate));

                // Set default owner ID to 0
                if this.owner_id<0 or this.owner_id>3 then
                    this.owner_id = 0;
                end

                var _String&? direction_str = _PTR2REF(_new_String());
                _string_read_string(direction_str, package:reader, "direction");

                if direction_str == "left" then
                    this.direction = ED_LEFT;
                else/if direction_str == "right" then
                    this.direction = ED_RIGHT;
                else/if direction_str == "misc" then
                    this.direction = ED_MISC;
                else
                    _log_error("unknown direction: '%1%'", direction_str);
                    this.direction = ED_MISC;
                end

                _delete_obj(direction_str);
            end;
        end;
    with
        every package in NEW_EXIT do
            spawn Exit with
                package:result = &this;

                this.desc = _PTR2REF(_new_ResDescriptor());
                this.smallmap_symbol = _PTR2REF(_new_SpriteA("core/misc/smallmap_exit"));

                _read_position(package:reader, this.pos);
                this.construct(package:reader); //can't put reference initiation there =(

                this.flag = _PTR2REF(_new_SpriteA(_scc2("core/misc/flag", _StringUtil__to_string(this.owner_id))));
                this.sprite = _PTR2REF(_new_SpriteA(_deref(this.desc)));
            end;
        end
    with
        every package in NEW_FAKE_EXIT do
            spawn FakeExit with
                package:result = &this;

                this.sprite = _PTR2REF(_new_SpriteA("traps/fake_exit"));
                this.smallmap_symbol = _PTR2REF(_new_SpriteA("core/misc/smallmap_exit"));
                this.smashing = false;

                _read_position(package:reader, this.pos);
                this.pos.x = this.pos.x - (float)this.sprite.get_width()/2;
                this.pos.y = this.pos.y - (float)this.sprite.get_height();
            end;
        end
    with
        every package in NEW_GROUNDPIECE do
            spawn Groundpiece with
                package:result = &this;

                _read_position(package:reader, this.pos);
                this.desc = _PTR2REF(_new_ResDescriptor());
                package:reader:read_desc("surface", _deref(this.desc));
                this.gptype = _GT_GROUND;
                _reader_read_Groundtype(package:reader, "type", _PTR2REF(this.gptype));
            end;
        end
    with
        every package in NEW_GUILLOTINE do
            spawn Guillotine with
                package:result = &this;

                this.sprite_kill_right = _PTR2REF(_new_SpriteA("traps/guillotinekill/right"));
                this.sprite_kill_left = _PTR2REF(_new_SpriteA("traps/guillotinekill/left"));
                this.sprite_idle = _PTR2REF(_new_SpriteA("traps/guillotineidle"));
                this.direction = _new_Direction();
                this.killing = false;

                _read_position(package:reader, this.pos);
                this.sprite_kill_right.set_play_loop(false);
                this.sprite_kill_left.set_play_loop(false);
                this.sprite_idle.set_play_loop(true);
            end;
        end
    with
        every package in NEW_HAMMER do
            spawn Hammer with
                package:result = &this;

                this.sprite = _PTR2REF(_new_SpriteA("traps/hammer"));
                _read_position(package:reader, this.pos);
            end;
        end
    with
        every package in NEW_HOTSPOT do
            spawn Hotspot with
                package:result = &this;

                var _ResDescriptor&? desc = _PTR2REF(_new_ResDescriptor());

                _read_position(package:reader, this.pos);
                package:reader:read_desc  ("surface",  _deref(desc));
                package:reader:read_float ("parallax", _PTR2REF(this.para));

                this.sprite = _PTR2REF(_new_SpriteA(_deref(desc)));

                _delete_obj(desc);
            end;
        end
    with
        every package in NEW_ICE_BLOCK do
            spawn IceBlock with
                package:result = &this;

                this.block_sur = _PTR2REF(_new_SpriteA("worldobjs/iceblock"));
                this.block_sur_cmap = _PTR2REF(_new_CollisionMask("worldobjs/iceblock_cmap"));

                _read_position(package:reader, this.pos);
                if not package:reader:read_int("repeat", _PTR2REF(this.width)) then
                    _log_warn("old 'width' tag used");
                    package:reader:read_int("width", _PTR2REF(this.width));
                end
            end;
        end
    with
        every package in NEW_LASER_EXIT do
            spawn LaserExit with
                package:result = &this;

                this.surface = _PTR2REF(_new_SpriteA("traps/laser_exit"));
                _read_position(package:reader, this.pos);
            end;
        end
    with
        every package in NEW_LIQUID do
            spawn Liquid with
                package:result = &this;

                this.width = 0;

                var _ResDescriptor&? desc = _PTR2REF(_new_ResDescriptor());

                _read_position(package:reader, this.pos);
                package:reader:read_desc  ("surface",  _deref(desc));
                package:reader:read_int   ("repeat",   _PTR2REF(this.width));

                this.sprite = _PTR2REF(_new_SpriteA(_deref(desc)));
            end;
        end
    with
        every package in NEW_RAIN_GENERATOR do
            spawn RainGenerator with
                package:result = &this;
            end;
        end
    with
        every package in NEW_SMASHER do
            spawn Smasher with
                package:result = &this;

                this.sprite = _PTR2REF(_new_SpriteA("traps/smasher"));
                _read_position(package:reader, this.pos);
                _assert(this.sprite.get_frame_count() == 6);
            end;
        end
    with
        every package in NEW_SNOW_GENERATOR do
            spawn SnowGenerator with
                package:result = &this;

                this.intensity = 1;
                package:reader:read_float("intensity", _PTR2REF(this.intensity));
            end;
        end
    with
        every package in NEW_SOLID_COLOR_BACKGROUND do
            spawn SolidColorBackground with
                package:result = &this;

                this.color = _PTR2REF(_new_Color());
                if not package:reader:read_colori("colori", _deref(this.color)) then
                    package:reader:read_colorf("color", _deref(this.color));
                end
            end;
        end
    with
        every package in NEW_SPIKE do
            spawn Spike with
                package:result = &this;

                this.surface = _PTR2REF(_new_SpriteA("traps/spike"));
                _read_position(package:reader, this.pos);
            end;
        end
    with
        every package in NEW_STARFIELD_BACKGROUND do
            spawn StarfieldBackground with
                package:result = &this;

                this.small_stars_count = 100;
                this.middle_stars_count = 50;
                this.large_stars_count = 25;

                package:reader:read_int("small-stars", _PTR2REF(this.small_stars_count));
                package:reader:read_int("middle-stars", _PTR2REF(this.middle_stars_count));
                package:reader:read_int("large-stars", _PTR2REF(this.large_stars_count));
            end;
        end
    with
        every package in NEW_SURFACE_BACKGROUND do
            spawn SurfaceBackground with
                package:result = &this;

                this.para_x = 0.5;
                this.para_y = 0.5;
                this.scroll_x = 0;
                this.scroll_y = 0;
                this.color = _PTR2REF(_new_Color(0, 0, 0, 0));
                this.stretch_x = false;
                this.stretch_y = false;
                this.keep_aspect = false;
                this.scroll_ox = 0;
                this.scroll_oy = 0;

                var bool res;
                _read_position2(package:reader, this.pos, res);
                if not res then
                    this.pos.x = 0;
                    this.pos.y = 0;
                    this.pos.z = -150;
                end

                var _ResDescriptor&? desc = _PTR2REF(_new_ResDescriptor());
                package:reader:read_desc("surface",  _deref(desc));

                if not package:reader:read_colori("colori", _deref(this.color)) then
                    package:reader:read_colorf("color", _deref(this.color));
                end

                package:reader:read_float("para-x", _PTR2REF(this.para_x));
                package:reader:read_float("para-y", _PTR2REF(this.para_y));

                package:reader:read_float("scroll-x", _PTR2REF(this.scroll_x));
                package:reader:read_float("scroll-y", _PTR2REF(this.scroll_y));

                package:reader:read_bool("stretch-x", _PTR2REF(this.stretch_x));
                package:reader:read_bool("stretch-y", _PTR2REF(this.stretch_y));

                package:reader:read_bool("keep-aspect", _PTR2REF(this.keep_aspect));

                if not this.stretch_x and not this.stretch_y and this.color.a == 0 then
                    //orignal FIXME: would be nice to allow surface manipulation with
                    // animated sprites, but it's not that easy to do
                    this.sprite = _PTR2REF(_new_SpriteA(_deref(desc)));
                else
                    var _Surface&? surface = _new_Surface();
                    _opeq(surface, _Resource__load_surface(_deref(desc)));

                    if this.color.a != 0 and surface.is_indexed() then
                        if surface.has_colorkey() then
                            _opeq(surface, surface.convert_to_rgba());
                        else
                            _opeq(surface, surface.convert_to_rgb());
                        end
                    end

                    surface.fill(_deref(this.color));

                    // Scaling Code
                    if this.stretch_x and this.stretch_y then
                        _opeq(surface, surface.scale(global:world:get_width(), global:world:get_height()));
                    else/if this.stretch_x and not this.stretch_y then
                        if this.keep_aspect then
                            var float aspect = (float)surface.get_height() / (float)surface.get_width();
                            _opeq(surface, surface.scale(global:world:get_width(), (int)((float)global:world:get_width()*aspect)));
                        else
                            _opeq(surface, surface.scale(global:world:get_width(), surface.get_height()));
                        end
                    else/if not this.stretch_x and this.stretch_y then
                        if this.keep_aspect then
                            var float aspect = (float)surface.get_width() / (float)surface.get_height();
                            _opeq(surface, surface.scale((int)((float)global:world:get_height()*aspect), global:world:get_height()));
                        else
                            _opeq(surface, surface.scale(surface.get_width(), global:world:get_height()));
                        end
                    end

                    this.sprite = _PTR2REF(_new_SpriteA(_deref(surface)));
                end

                _delete_obj(desc);
            end;
        end
    with
        every package in NEW_SWITCH_DOOR_DOOR do
            spawn SwitchDoorDoor in switch_door_doors with
                package:result = &this;

                this.id = _PTR2REF(_new_String());
                _string_read_string(this.id, package:reader, "id");

                this.door_box = _PTR2REF(_new_SpriteA("worldobjs/switchdoor_box"));
                this.door_box_cmap = _PTR2REF(_new_CollisionMask("worldobjs/switchdoor_box"));
                this.door_tile = _PTR2REF(_new_SpriteA("worldobjs/switchdoor_tile"));
                this.door_tile_cmap = _PTR2REF(_new_CollisionMask("worldobjs/switchdoor_tile_cmap"));
                this.is_opening = false;

                _read_position(package:reader, this.pos);

                package:reader:read_int("height", _PTR2REF(this.door_height));
                this.current_door_height = this.door_height;
            end;
        end
    with
        every package in NEW_SWITCH_DOOR_SWITCH do
            spawn SwitchDoorSwitch with
                package:result = &this;

                this.switch_sur = _PTR2REF(_new_SpriteA("worldobjs/switchdoor_switch"));
                this.is_triggered = false;
                this.m_target = _PTR2REF(_new_String());
                _string_read_string(this.m_target, package:reader, "target-id");
                _read_position(package:reader, this.pos);
            end;
        end
    with
        every package in NEW_TELEPORTER do
            spawn Teleporter with
                package:result = &this;

                this.sprite = _PTR2REF(_new_SpriteA("worldobjs/teleporter"));
                _read_position(package:reader, this.pos);
                this.target_id = _PTR2REF(_new_String());
                _string_read_string(this.target_id, package:reader, "target-id");
            end;
        end
    with
        every package in NEW_TELEPORTER_TARGET do
            spawn TeleporterTarget in teleporter_targets with
                package:result = &this;

                this.id = _PTR2REF(_new_String());
                _string_read_string(this.id, package:reader, "id");
                this.sprite = _PTR2REF(_new_SpriteA("worldobjs/teleportertarget"));
                _read_position(package:reader, this.pos);
            end;
        end
    with
        every w in WORLD_DELETE do
            if w == &me then
                objs.iterate(_CEU_IN_WORLD_DELETE_OBJECT);
                break;
            end
        end
    with
        every object in WORLD_DELETE_OBJECT do
            emit object:e_DELETE;
        end
    end
end

#endif
