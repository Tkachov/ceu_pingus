#ifndef WORLD_CEU
#define WORLD_CEU

#include "../c.ceu"
#include "../sdl.ceu"
#include "iworld.ceu"
#include "pingu.ceu"
#include "pingu_holder.ceu"
#include "worldobjs/conveyor_belt.ceu"
#include "worldobjs/entrance.ceu"
#include "worldobjs/exit.ceu"
#include "worldobjs/fake_exit.ceu"
#include "worldobjs/guillotine.ceu"
#include "worldobjs/hammer.ceu"
#include "worldobjs/ice_block.ceu"
#include "worldobjs/laser_exit.ceu"
#include "worldobjs/smasher.ceu"
#include "worldobjs/spike.ceu"
#include "worldobjs/switch_door_switch.ceu"
#include "worldobjs/teleporter.ceu"

input _World* DELETE_WORLD;
input _WOCPackage* NEW_CONVEYOR_BELT;
input _WEntrance* NEW_ENTRANCE;
input _WOCPackage* NEW_EXIT;
input _WOCPackage* NEW_FAKE_EXIT;
input _WOCPackage* NEW_GUILLOTINE;
input _WOCPackage* NEW_HAMMER;
input _WOCPackage* NEW_ICE_BLOCK;
input _WOCPackage* NEW_LASER_EXIT;
input _WOCPackage* NEW_SMASHER;
input _WOCPackage* NEW_SPIKE;
input _WSwitchDoorSwitch* NEW_SWITCH_DOOR_SWITCH;
input _WTeleporter* NEW_TELEPORTER;

class World with
    interface IWorld;
    var _World& me;
do
    var _World&? me_ = _PTR2REF((_World*)&this.me);
    var PinguHolder holder with
        this.me = me_.pingus;
    end;

    function (void) => IPinguHolder* get_pingus do
        return holder;
    end

    par/or do
        every w in WORLD_UPDATE do
            if w != &me_ then
                continue;
            end

            if me_.do_armageddon and me_.game_time%4 == 0 then
                loop pingu in holder.all_pingus do
                    if pingu:get_current_action() == _A_BOMBER or pingu:get_current_action() == _A_DROWN or
                       pingu:get_current_action() == _A_SPLASHED or pingu:get_current_action() == _A_LASERKILL or
                       pingu:get_current_action() == _A_DEAD or pingu:get_current_action() == _A_EXITED then
                        continue;
                    end

                    emit pingu:e_CHANGE_ACTION => _A_BOMBER;
                    break;
                end
            end
        end
    with
        every package in NEW_CONVEYOR_BELT do
            spawn ConveyorBelt with
                this.me = _new_WorldObj();
                package:result = this.me;

                this.left_sur = _PTR2REF(_new_SpriteA("worldobjs/conveyorbelt_left"));
                this.right_sur = _PTR2REF(_new_SpriteA("worldobjs/conveyorbelt_right"));
                this.middle_sur = _PTR2REF(_new_SpriteA("worldobjs/conveyorbelt_middle"));

                package:reader:read_vector("position", _PTR2REF(this.me:pos));
                if not package:reader:read_int("repeat", _PTR2REF(this.width)) then
                    _log_warn("old 'width' tag used");
                    package:reader:read_int("width", _PTR2REF(this.width));
                end
                package:reader:read_float("speed", _PTR2REF(this.speed));
            end;
        end
    with
        every new_entrance in NEW_ENTRANCE do
            spawn Entrance with
                this.me = _PTR2REF(new_entrance);
            end;
        end
    with
        every package in NEW_EXIT do
            spawn Exit with
                this.me = _new_WorldObj();
                package:result = this.me;

                this.desc = _PTR2REF(_new_ResDescriptor());
                this.smallmap_symbol = _PTR2REF(_new_SpriteA("core/misc/smallmap_exit"));

                package:reader:read_vector("position", _PTR2REF(this.me:pos));
                package:reader:read_desc  ("surface",  _deref(this.desc));
                package:reader:read_int   ("owner-id", _PTR2REF(this.owner_id));

                // Set default owner ID to 0
                if this.owner_id<0 or this.owner_id>3 then
                    this.owner_id = 0;
                end

                this.flag = _PTR2REF(_new_SpriteA(_scc2("core/misc/flag", _StringUtil__to_string(this.owner_id))));
                this.sprite = _PTR2REF(_new_SpriteA(_deref(this.desc)));
            end;
        end
    with
        every package in NEW_FAKE_EXIT do
            spawn FakeExit with
                this.me = _new_WorldObj();
                package:result = this.me;

                this.sprite = _PTR2REF(_new_SpriteA("traps/fake_exit"));
                this.smallmap_symbol = _PTR2REF(_new_SpriteA("core/misc/smallmap_exit"));
                this.smashing = false;

                package:reader:read_vector("position", _PTR2REF(this.me:pos));
                this.me:pos.x = this.me:pos.x - (float)this.sprite.get_width()/2;
                this.me:pos.y = this.me:pos.y - (float)this.sprite.get_height();
            end;
        end
    with
        every package in NEW_GUILLOTINE do
            spawn Guillotine with
                this.me = _new_WorldObj();
                package:result = this.me;

                this.sprite_kill_right = _PTR2REF(_new_SpriteA("traps/guillotinekill/right"));
                this.sprite_kill_left = _PTR2REF(_new_SpriteA("traps/guillotinekill/left"));
                this.sprite_idle = _PTR2REF(_new_SpriteA("traps/guillotineidle"));
                this.direction = _new_Direction();
                this.killing = false;

                package:reader:read_vector("position", _PTR2REF(this.me:pos));
                this.sprite_kill_right.set_play_loop(false);
                this.sprite_kill_left.set_play_loop(false);
                this.sprite_idle.set_play_loop(true);
            end;
        end
    with
        every package in NEW_HAMMER do
            spawn Hammer with
                this.me = _new_WorldObj();
                package:result = this.me;

                this.sprite = _PTR2REF(_new_SpriteA("traps/hammer"));
                package:reader:read_vector("position", _PTR2REF(this.me:pos));
            end;
        end
    with
        every package in NEW_ICE_BLOCK do
            spawn IceBlock with
                this.me = _new_WorldObj();
                package:result = this.me;

                this.block_sur = _PTR2REF(_new_SpriteA("worldobjs/iceblock"));
                this.block_sur_cmap = _PTR2REF(_new_CollisionMask("worldobjs/iceblock_cmap"));

                package:reader:read_vector("position", _PTR2REF(this.me:pos));
                if not package:reader:read_int("repeat", _PTR2REF(this.width)) then
                    _log_warn("old 'width' tag used");
                    package:reader:read_int("width", _PTR2REF(this.width));
                end
            end;
        end
    with
        every package in NEW_LASER_EXIT do
            spawn LaserExit with
                this.me = _new_WorldObj();
                package:result = this.me;

                this.surface = _PTR2REF(_new_SpriteA("traps/laser_exit"));
                package:reader:read_vector("position", _PTR2REF(this.me:pos));
            end;
        end
    with
        every package in NEW_SMASHER do
            spawn Smasher with
                this.me = _new_WorldObj();
                package:result = this.me;

                this.sprite = _PTR2REF(_new_SpriteA("traps/smasher"));
                package:reader:read_vector("position", _PTR2REF(this.me:pos));
                _assert(this.sprite.get_frame_count() == 6);
            end;
        end
    with
        every package in NEW_SPIKE do
            spawn Spike with
                this.me = _new_WorldObj();
                package:result = this.me;

                this.surface = _PTR2REF(_new_SpriteA("traps/spike"));
                package:reader:read_vector("position", _PTR2REF(this.me:pos));
            end;
        end
    with
        every new_switch_door_switch in NEW_SWITCH_DOOR_SWITCH do
            spawn SwitchDoorSwitch with
                this.me = _PTR2REF(new_switch_door_switch);
            end;
        end
    with
        every new_teleporter in NEW_TELEPORTER do
            spawn Teleporter with
                this.me = _PTR2REF(new_teleporter);
            end;
        end
    with
        var _World* p = await DELETE_WORLD until (p == &me_);
    end

    await 1s;
end

#endif
