#ifndef BASHERACTION_CEU
#define BASHERACTION_CEU

#include "../../c.ceu"
#include "../../sdl.ceu"
#include "../../engine/display/scene_context.ceu"
#include "../../math/vector3f.ceu"
#include "../iaction.ceu"
#include "../ipingu.ceu"
#include "../state_sprite.ceu"

native/pre do
    ##include "pingus/actions/basher.hpp"
    ##define ABasher Actions::Basher

    ##include "engine/sound/sound.hpp"
    ##define Sound_PingusSound_play_sound Sound::PingusSound::play_sound
end

class BasherAction with
    interface IAction;
do
    var _ABasher&? basher = _PTR2REF((_ABasher*)pingu.set_ptr(_A_BASHER));
    var bool odd_frame = true; //-1th, I hope first block will execute not odd_frame faster

    var StateSprite sprite;
    load_file_directions(sprite, basher, "/basher/");

    par do
        every gc in pingu.e_DRAW_CALLED do
            _gc_color_draw2(gc, sprite.get(basher.pingu:direction), basher.pingu:get_pos());
        end
    with
        every pingu.e_UPDATE_CALLED do
            sprite.get(basher.pingu:direction):update();
            odd_frame = not odd_frame;
        end
    with
        loop do
            await pingu.e_UPDATE_CALLED;

            /// WALK_FORWARD ///   
            //Basher turns into a Faller if it goes down more than <max_steps_down>
            var int max_steps_down = 3;

            var int y_inc = 0;

            // Find the correct y position to go to next
            loop do
                if y_inc < -max_steps_down then break; end

                // If there is something below, get out of this loop
                if basher.rel_getpixel(0, y_inc-1) != _GT_NOTHING then
                    break;
                end

                y_inc = y_inc-1;
            end

            if y_inc < -max_steps_down then        
                // The step down is too much.  So stop being a Basher and return false to be a Faller.    
                escape _A_FALLER;
            else
                // Note that Pingu::set_pos() is the 'reverse' of the y co-ords of
                // rel_getpixel()
                basher.pingu:set_pos(
                    basher.pingu:get_x() + (float)basher.pingu:direction,
                    basher.pingu:get_y() - (float)y_inc
                );
            end
            ////////////////////

            // If on walking forward the Basher has now walked on to water or lava
            if basher.rel_getpixel(0, -1) == _GT_WATER or basher.rel_getpixel(0, -1) == _GT_LAVA then
                escape _A_DROWN;
            // If walking on to something (i.e. hasn't fallen)
            else/if basher.rel_getpixel(0, -1) != _GT_NOTHING then
                //original FIXME: Game logic must be separate from Sprite
                var float progress = (float)(sprite.get(basher.pingu:direction):get_current_frame())/(float)(sprite.get(basher.pingu:direction):get_frame_count());

                // If the Basher has walked into something that it won't be able to
                // bash
                if basher.rel_getpixel(0, 0) == _GT_SOLID or basher.rel_getpixel(0, _pingu_height) == _GT_SOLID then
                    // Change direction and let walk code walk forward/up to get out.
                    _Sound_PingusSound_play_sound("chink");
                    basher.pingu:direction.change();
                    escape _A_WALKER;
                else/if basher.have_something_to_dig() then
                    // We only bash every second step, cause the Pingus would
                    // get trapped otherwise in the bashing area.
                    if not odd_frame then
                        basher.bash();
                    end
                else/if progress > 0.6 then
                    //original FIXME: EVIL! Engine must not relay on graphic
                    escape _A_WALKER;
                end
            end

            await pingu.e_UPDATE_CALLED;
            await pingu.e_UPDATE_CALLED;
        end
    end
end

#endif
