#ifndef BASHERACTION_CEU
#define BASHERACTION_CEU

#include "../../c.ceu"
#include "../../sdl.ceu"
#include "../../engine/display/scene_context.ceu"
#include "../../engine/sound/sound.ceu"
#include "../../math/vector3f.ceu"
#include "../collision_mask.ceu"
#include "../iaction.ceu"
#include "../ipingu.ceu"
#include "../state_sprite.ceu"
#include "../worldobj.ceu"

class BasherAction with
    interface IAction;
    interface IPinguAction;
do
    pingu.ceu_action = &this;

    function (int a) => bool change_allowed do
        return true;
    end

    catchable = true;

    function @rec (void) => Vector3f get_center_pos do
        var Vector3f result = call/rec (call/rec pingu.get_pos());
        result.y = result.y - 16;
        return result;
    end

    function (void) => _const_char_string get_name do
        return _get_screenname(_A_BASHER);
    end

    var bool odd_frame = true; //-1th, I hope first block will execute not odd_frame faster
    var bool first_bash = true;

    var StateSprite sprite;
    load_file_directions(sprite, "/basher/");

    var _CollisionMask&? bash_radius = _new_CollisionMask("pingus/common/bash_radius_gfx", "pingus/common/bash_radius");
    finalize with _delete_obj(bash_radius); end;

    _assert(bash_radius.get_width() % 2 == 0);
    var int bash_reach = bash_radius.get_width();

    /* Defines the minimum "wall" height needed for a bash to happen. */
    var int min_bash_height = 5;

    /* Defines the maximum height up to which a check is made to see if there
       is anything to bash.  Best to make this at least (min_bash_height +
       pingu_height). */
    var int max_bash_height = 33;

    function @rec (void) => void bash do
        global:world:remove(&bash_radius,
                            (int)pingu.get_x() - bash_radius.get_width()/2,
                            (int)pingu.get_y() - bash_radius.get_height()+1);
    end

    function @rec (void) => bool have_something_to_dig do
        if first_bash then
            first_bash = false;
            return true;
        end

        // Check that there is something "within" the Basher's reach
        loop/1000 x in bash_reach+1 do
            var int y = min_bash_height;
            loop/1000 do
                if y > max_bash_height then
                    break;
                end

                if (call/rec pingu.rel_getpixel(x, y)) == _GT_GROUND then
                    _log_debug("Basher: Found something to dig...");
                    return true;
                end

                y = y+1;
            end
        end

        return false;
    end

    // Start a bash even if the action will stop instantly after the first bash
    call/rec bash();

    par do
        every gc in pingu.e_DRAW_CALLED do
            _gc_color_draw2(gc, sprite.get(pingu.direction().value), _toVector3f((call/rec pingu.get_pos())));
        end
    with
        every global:e_PINGU_UPDATE_ALL do
            sprite.get(pingu.direction().value):update();
            odd_frame = not odd_frame;
        end
    with
        loop do
            await global:e_PINGU_UPDATE_ALL;

            /// WALK_FORWARD ///
            //Basher turns into a Faller if it goes down more than <max_steps_down>
            var int max_steps_down = 3;

            var int y_inc = 0;

            // Find the correct y position to go to next
            loop/100 do
                if y_inc < -max_steps_down then break; end

                // If there is something below, get out of this loop
                if (call/rec pingu.rel_getpixel(0, y_inc-1)) != _GT_NOTHING then
                    break;
                end

                y_inc = y_inc-1;
            end

            if y_inc < -max_steps_down then
                // The step down is too much.  So stop being a Basher and return false to be a Faller.
                escape _A_FALLER;
            else
                // Note that Pingu::set_pos() is the 'reverse' of the y co-ords of
                // rel_getpixel()
                pingu.set_posf(
                    pingu.get_x() + (float)pingu.direction().value,
                    pingu.get_y() - (float)y_inc
                );
            end
            ////////////////////

            // If on walking forward the Basher has now walked on to water or lava
            if (call/rec pingu.rel_getpixel(0, -1)) == _GT_WATER or (call/rec pingu.rel_getpixel(0, -1)) == _GT_LAVA then
                escape _A_DROWN;
            // If walking on to something (i.e. hasn't fallen)
            else/if (call/rec pingu.rel_getpixel(0, -1)) != _GT_NOTHING then
                //original FIXME: Game logic must be separate from Sprite
                var float progress = (float)(sprite.get(pingu.direction().value):get_current_frame())/(float)(sprite.get(pingu.direction().value):get_frame_count());

                // If the Basher has walked into something that it won't be able to
                // bash
                if (call/rec pingu.rel_getpixel(0, 0)) == _GT_SOLID or (call/rec pingu.rel_getpixel(0, _pingu_height)) == _GT_SOLID then
                    // Change direction and let walk code walk forward/up to get out.
                    _Sound_PingusSound_play_sound("chink");
                    emit pingu.direction().change;
                    escape _A_WALKER;
                else/if call/rec have_something_to_dig() then
                    // We only bash every second step, cause the Pingus would
                    // get trapped otherwise in the bashing area.
                    if not odd_frame then
                        call/rec bash();
                    end
                else/if progress > 0.6 then
                    //original FIXME: EVIL! Engine must not relay on graphic
                    escape _A_WALKER;
                end
            end

            await global:e_PINGU_UPDATE_ALL;
            await global:e_PINGU_UPDATE_ALL;
        end
    end
end

#endif
