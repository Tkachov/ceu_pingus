#ifndef FALLERACTION_CEU
#define FALLERACTION_CEU

#include "../../c.ceu"
#include "../../sdl.ceu"
#include "../../engine/display/scene_context.ceu"
#include "../../math/vector3f.ceu"
#include "../iaction.ceu"
#include "../ipingu.ceu"
#include "../state_sprite.ceu"
#include "../movers/linear_mover.ceu"

native/pre do
    ##include "pingus/colliders/pingu_collider.hpp"
    ##include "pingus/pingu_enums.hpp"
    ##include "pingus/worldobj.hpp"
    ##define WorldObj__get_world WorldObj::get_world
    ##define Colliders__PinguCollider Colliders::PinguCollider
    ##define Math__abs Math::abs
end

native @pure _Colliders__PinguCollider(),
             _WorldObj__get_world();

class FallerAction with
    interface IAction;
    interface IPinguAction;
do
    var _PinguAction& faller = _PTR2REF(pingu.set_ptr(_A_FALLER));
    pingu.ceu_action = &this;

    function (int a) => bool change_allowed do
        return (a==_A_FLOATER or a==_A_CLIMBER or a==_A_BOMBER);
    end

    catchable = true;

    function (void) => Vector3f get_center_pos do
        var Vector3f result;
        result.x = pingu.me.get_pos().x;
        result.y = pingu.me.get_pos().y - 16;
        result.z = pingu.me.get_pos().z;
        return result;
    end

    var StateSprite sprite;
    var StateSprite tumbler;
    load_file_directions(sprite, faller, "/faller/");
    load_file_directions(tumbler, faller, "/tumbler/");

    var _Movers_LinearMover&? mover = _new_LinearMover();
    finalize with _delete_LinearMover(mover); end;

    function (void) => bool is_tumbling do
        // If we are going fast enough to get smashed, start tumbling
        return (_Math__abs(pingu.me.get_velocity().x) > _deadly_velocity or
                _Math__abs(pingu.me.get_velocity().y) > _deadly_velocity);
    end

    par do
        every gc in pingu.e_DRAW_CALLED do
            if is_tumbling() then
                _gc_color_draw2(gc, tumbler.get(pingu.me.direction), pingu.me.get_pos());
            else
                _gc_color_draw2(gc, sprite.get(pingu.me.direction), pingu.me.get_pos());
            end
        end
    with
        every pingu.e_UPDATE_CALLED do
            if is_tumbling() then
                tumbler.get(pingu.me.direction):update();
            else
                sprite.get(pingu.me.direction):update();
            end

            /* original Pingus FIXME:

               This should be triggered at a later point, when close to
               deadly_velocity or something like that. A translation
               animation for the floater might also help
             */
            if pingu.me.get_velocity().y > 5.0 and pingu.has_fall_action() then
                escape pingu.get_fall_action();
            end

            // Apply gravity
            pingu.me.set_velocity(
                pingu.me.get_velocity()
              + _Vector3f(0, _WorldObj__get_world():get_gravity()) );

            // Move the Pingu as far is it can go
            mover.reset(pingu.me.get_pos());
            mover.update(pingu.me.get_velocity(), _Colliders__PinguCollider(_pingu_height));
            pingu.me.set_pos(mover.get_pos());

            var bool collided = mover.collided();
            var Vector3f velocity;
            velocity.x = pingu.me.get_velocity().x;
            velocity.y = pingu.me.get_velocity().y;

            // If the Pingu collided with something...
            if collided then
                if pingu.rel_getpixel(0, -1) == _GT_NOTHING and
                   pingu.rel_getpixel(0, -2) == _GT_NOTHING and
                   pingu.rel_getpixel(0, -3) == _GT_NOTHING and
                   pingu.rel_getpixel(1, 0) != _GT_NOTHING and
                   pingu.rel_getpixel(1, 0) != _GT_BRIDGE
                then
                    // Make Pingu bounce off wall
                    velocity.x = -(velocity.x/3.0);

                    // Make the Pingu face the correct direction.  NB: Pingu may
                    // previously have been facing in the opposite direction of its
                    // velocity because of an explosion.
                    if velocity.x > 0 then pingu.me.direction.right();
                    else pingu.me.direction.left(); end

                    pingu.me.set_velocity(_Vector3f(velocity.x, velocity.y));
                else/if velocity.y > 0.0 // If the Pingu collided into something while moving down...
                then
                    // Ping is on ground/water/something
                    if pingu.rel_getpixel(0, -1) == _GT_WATER or
                       pingu.rel_getpixel(0, -1) == _GT_LAVA
                    then
                        escape _A_DROWN;
                    // Did we stop too fast?
                    else/if _Math__abs(velocity.y) > _deadly_velocity then
                        //log_info("Pingus splashed: " << pingu:get_velocity().y << " " << deadly_velocity);
                        escape _A_SPLASHED;
                    else
                        // This is where the jumper bug happens
                        //log_info("Reached the unreachable: " << pingu:get_velocity().y);
                        if pingu.get_previous_action() == _A_BLOCKER then
                            escape pingu.get_previous_action();
                        else
                            escape _A_WALKER;
                        end
                    end
                // If the Pingu collided into something while moving up...
                else
                    // Don't make the Pingu go up any further.
                    velocity.y = 0;
                    velocity.x = velocity.x/3.0;

                    pingu.me.set_velocity(_toVector3f(velocity));
                end
            end
        end
    end
end

#endif
