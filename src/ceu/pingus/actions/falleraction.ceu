#ifndef FALLERACTION_CEU
#define FALLERACTION_CEU

#include "../../c.ceu"
#include "../../sdl.ceu"
#include "../../engine/display/scene_context.ceu"
#include "../../math/vector3f.ceu"
#include "../iaction.ceu"
#include "../ipingu.ceu"
#include "../state_sprite.ceu"
#include "../movers/linear_mover.ceu"

native/pre do
    ##include "pingus/colliders/pingu_collider.hpp"
    ##include "pingus/pingu_enums.hpp"
    ##include "pingus/worldobj.hpp"
    ##define WorldObj__get_world WorldObj::get_world
    ##define Colliders__PinguCollider Colliders::PinguCollider
    ##define Math__abs Math::abs
end

native @pure _Colliders__PinguCollider(),
             _WorldObj__get_world();

class FallerAction with
    interface IAction;
    interface IPinguAction;
do
    pingu.ceu_action = &this;

    function (int a) => bool change_allowed do
        return (a==_A_FLOATER or a==_A_CLIMBER or a==_A_BOMBER);
    end

    catchable = true;

    function @rec (void) => Vector3f get_center_pos do
        var Vector3f result;
        result.x = pingu.get_pos().x;
        result.y = pingu.get_pos().y - 16;
        result.z = pingu.get_pos().z;
        return result;
    end

    function (void) => _const_char_string get_name do
        return _get_screenname(_A_FALLER);
    end

    var StateSprite sprite;
    var StateSprite tumbler;
    load_file_directions(sprite, "/faller/");
    load_file_directions(tumbler, "/tumbler/");

    var _Movers_LinearMover&? mover = _new_LinearMover();
    finalize with _delete_obj(mover); end;

    function @rec (void) => bool is_tumbling do
        // If we are going fast enough to get smashed, start tumbling
        return (_Math__abs(pingu.get_velocity().x) > _deadly_velocity or
                _Math__abs(pingu.get_velocity().y) > _deadly_velocity);
    end

    par do
        every gc in pingu.e_DRAW_CALLED do
            if call/rec is_tumbling() then
                _gc_color_draw2(gc, tumbler.get(pingu.direction), pingu.get_pos());
            else
                _gc_color_draw2(gc, sprite.get(pingu.direction), pingu.get_pos());
            end
        end
    with
        every PINGU_UPDATE_ALL do
            if call/rec is_tumbling() then
                tumbler.get(pingu.direction):update();
            else
                sprite.get(pingu.direction):update();
            end

            /* original Pingus FIXME:

               This should be triggered at a later point, when close to
               deadly_velocity or something like that. A translation
               animation for the floater might also help
             */
            if pingu.get_velocity().y > 5.0 and pingu.has_fall_action() then
                escape pingu.get_fall_action();
            end

            // Apply gravity
            var Vector3f vel = pingu.get_velocity();
            vel.y = vel.y + _WorldObj__get_world():get_gravity();
            pingu.set_velocity(vel);

            // Move the Pingu as far is it can go
            mover.reset(pingu.get_pos());
            mover.update(_toVector3f(pingu.get_velocity()), _Colliders__PinguCollider(_pingu_height));
            pingu.set_pos(mover.get_pos());

            var bool collided = mover.collided();
            var Vector3f velocity = pingu.get_velocity();

            // If the Pingu collided with something...
            if collided then
                if pingu.rel_getpixel(0, -1) == _GT_NOTHING and
                   pingu.rel_getpixel(0, -2) == _GT_NOTHING and
                   pingu.rel_getpixel(0, -3) == _GT_NOTHING and
                   pingu.rel_getpixel(1, 0) != _GT_NOTHING and
                   pingu.rel_getpixel(1, 0) != _GT_BRIDGE
                then
                    // Make Pingu bounce off wall
                    velocity.x = -(velocity.x/3.0);

                    // Make the Pingu face the correct direction.  NB: Pingu may
                    // previously have been facing in the opposite direction of its
                    // velocity because of an explosion.
                    if velocity.x > 0 then pingu.direction.right();
                    else pingu.direction.left(); end

                    pingu.set_velocity(velocity);
                else/if velocity.y > 0.0 // If the Pingu collided into something while moving down...
                then
                    // Ping is on ground/water/something
                    if pingu.rel_getpixel(0, -1) == _GT_WATER or
                       pingu.rel_getpixel(0, -1) == _GT_LAVA
                    then
                        escape _A_DROWN;
                    // Did we stop too fast?
                    else/if _Math__abs(velocity.y) > _deadly_velocity then
                        //log_info("Pingus splashed: " << pingu.get_velocity().y << " " << deadly_velocity);
                        escape _A_SPLASHED;
                    else
                        // This is where the jumper bug happens
                        //log_info("Reached the unreachable: " << pingu.get_velocity().y);
                        if pingu.get_previous_action() == _A_BLOCKER then
                            escape pingu.get_previous_action();
                        else
                            escape _A_WALKER;
                        end
                    end
                // If the Pingu collided into something while moving up...
                else
                    // Don't make the Pingu go up any further.
                    velocity.y = 0;
                    velocity.x = velocity.x/3.0;

                    pingu.set_velocity(velocity);
                end
            end
        end
    end
end

#endif
