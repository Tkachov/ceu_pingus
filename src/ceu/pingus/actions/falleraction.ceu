#ifndef FALLERACTION_CEU
#define FALLERACTION_CEU

#include "../../c.ceu"
#include "../../sdl.ceu"
#include "../../engine/display/scene_context.ceu"
#include "../../math/vector3f.ceu"
#include "../iaction.ceu"
#include "../ipingu.ceu"
#include "../state_sprite.ceu"
#include "../movers/linear_mover.ceu"

native/pre do
    ##include "pingus/colliders/pingu_collider.hpp"
    ##include "pingus/pingu_enums.hpp"
    ##include "pingus/worldobj.hpp"
    ##define WorldObj__get_world WorldObj::get_world
    ##define Colliders__PinguCollider Colliders::PinguCollider
    ##define Math__abs Math::abs
end

native @pure _Colliders__PinguCollider(),
             _WorldObj__get_world();

class FallerAction with
    interface IAction;
do
    var _PinguAction& faller = _PTR2REF(pingu.set_ptr(_A_FALLER));

    var StateSprite sprite;
    var StateSprite tumbler;
    load_file_directions(sprite, faller, "/faller/");
    load_file_directions(tumbler, faller, "/tumbler/");

    var _Movers_LinearMover&? mover = _new_LinearMover();
    finalize with _delete_LinearMover(mover); end;

    function (void) => bool is_tumbling do
        // If we are going fast enough to get smashed, start tumbling
        return (_Math__abs(faller.pingu:get_velocity().x) > _deadly_velocity or
                _Math__abs(faller.pingu:get_velocity().y) > _deadly_velocity);
    end

    par do
        every package in ACTION_CHANGE_ALLOWED do
            if package:action != &faller then
                continue;
            end

            package:result = (package:new_action == _A_FLOATER or
                              package:new_action == _A_CLIMBER or
                              package:new_action == _A_BOMBER);
        end
    with
        every gc in pingu.e_DRAW_CALLED do
            if is_tumbling() then
                _gc_color_draw2(gc, tumbler.get(faller.pingu:direction), faller.pingu:get_pos());
            else
                _gc_color_draw2(gc, sprite.get(faller.pingu:direction), faller.pingu:get_pos());
            end
        end
    with
        every pingu.e_UPDATE_CALLED do
            if is_tumbling() then
                tumbler.get(faller.pingu:direction):update();
            else
                sprite.get(faller.pingu:direction):update();
            end

            /* original Pingus FIXME:

               This should be triggered at a later point, when close to
               deadly_velocity or something like that. A translation
               animation for the floater might also help
             */
            if faller.pingu:get_velocity().y > 5.0 and faller.pingu:has_fall_action() then
                escape faller.pingu:get_fall_action();
            end

            // Apply gravity
            faller.pingu:set_velocity(
                faller.pingu:get_velocity()
              + _Vector3f(0, _WorldObj__get_world():get_gravity()) );

            // Move the Pingu as far is it can go
            mover.reset(faller.pingu:get_pos());
            mover.update(faller.pingu:get_velocity(), _Colliders__PinguCollider(_pingu_height));
            faller.pingu:set_pos(mover.get_pos());

            var bool collided = mover.collided();
            var Vector3f velocity;
            velocity.x = faller.pingu:get_velocity().x;
            velocity.y = faller.pingu:get_velocity().y;

            // If the Pingu collided with something...
            if collided then
                if faller.rel_getpixel(0, -1) == _GT_NOTHING and
                   faller.rel_getpixel(0, -2) == _GT_NOTHING and
                   faller.rel_getpixel(0, -3) == _GT_NOTHING and
                   faller.rel_getpixel(1, 0) != _GT_NOTHING and
                   faller.rel_getpixel(1, 0) != _GT_BRIDGE
                then
                    // Make Pingu bounce off wall
                    velocity.x = -(velocity.x/3.0);

                    // Make the Pingu face the correct direction.  NB: Pingu may
                    // previously have been facing in the opposite direction of its
                    // velocity because of an explosion.
                    if velocity.x > 0 then faller.pingu:direction.right();
                    else faller.pingu:direction.left(); end

                    faller.pingu:set_velocity(_Vector3f(velocity.x, velocity.y));
                else/if velocity.y > 0.0 // If the Pingu collided into something while moving down...
                then
                    // Ping is on ground/water/something
                    if faller.rel_getpixel(0, -1) == _GT_WATER or
                       faller.rel_getpixel(0, -1) == _GT_LAVA
                    then
                        escape _A_DROWN;
                    // Did we stop too fast?
                    else/if _Math__abs(velocity.y) > _deadly_velocity then
                        //log_info("Pingus splashed: " << pingu:get_velocity().y << " " << deadly_velocity);
                        escape _A_SPLASHED;
                    else
                        // This is where the jumper bug happens
                        //log_info("Reached the unreachable: " << pingu:get_velocity().y);
                        if faller.pingu:get_previous_action() == _A_BLOCKER then
                            escape faller.pingu:get_previous_action();
                        else
                            escape _A_WALKER;
                        end
                    end
                // If the Pingu collided into something while moving up...
                else
                    // Don't make the Pingu go up any further.
                    velocity.y = 0;
                    velocity.x = velocity.x/3.0;

                    faller.pingu:set_velocity(_toVector3f(velocity));
                end
            end
        end
    end
end

#endif
