#ifndef BRIDGERACTION_CEU
#define BRIDGERACTION_CEU

#include "../../c.ceu"
#include "../../sdl.ceu"
#include "../../engine/display/scene_context.ceu"
#include "../../engine/sound/sound.ceu"
#include "../collision_mask.ceu"
#include "../iaction.ceu"
#include "../ipingu.ceu"
#include "../state_sprite.ceu"
#include "../worldobj.ceu"

native/pre do
    ##include "pingus/gettext.h"
    ##include "util/string_util.hpp"
    ##define make_name(b) std::string(_("Bridger") + std::string(" (" + StringUtil::to_string(b) + ")")).c_str()
end

native @pure _make_name();

//I want constants =(
#define MAX_BRICKS 15

class BridgerAction with
    interface IAction;
    interface IPinguAction;
do
    pingu.ceu_action = &this;

    function (int a) => bool change_allowed do
        return true;
    end

    catchable = true;

    function @rec (void) => Vector3f get_center_pos do
        var Vector3f result;
        result.x = pingu.get_pos().x;
        result.y = pingu.get_pos().y - 16;
        result.z = pingu.get_pos().z;
        return result;
    end

    var float x_offset = 6;
    var float y_offset = 4;
    var int bricks = MAX_BRICKS;
    var String name;
    name.set(_make_name(bricks));

    function (void) => _const_char_string get_name do
        return name.get();
    end

    var StateSprite walk_sprite;
    var StateSprite build_sprite;
    load_file_directions(walk_sprite, "/bridger_walk/");
    load_file_directions(build_sprite, "/bridger/");

    var _CollisionMask&? brick_l = _new_CollisionMask("other/brick_left");
    finalize with _delete_obj(brick_l); end;

    var _CollisionMask&? brick_r = _new_CollisionMask("other/brick_right");
    finalize with _delete_obj(brick_r); end;

    // way_is_free() needs to stop BRIDGERS from getting stuck between a brick
    // and the ceiling.  The routine also stops cases of Bridgers building up but
    // then not being able to walk all the way down the bridge the it has built.
    // Even though the routine may be the same as brick_placement_allowed(), it is
    // best to keep them apart as they may need to be independent of each other if
    // there needs to be a patch.
    function @rec (void) => bool way_is_free do
        loop i in 4 do
            var int x_inc = i+1;

            if pingu.rel_getpixel(x_inc, 2) != _GT_NOTHING
            or pingu.head_collision_on_walk(x_inc, 2) then
                return false;
            end
        end

        return true;
    end

    // brick_placement_allowed() is mainly for stopping WALKERS from getting stuck
    // between a brick and the ceiling.  Even though the routine may be the same,
    // as way_is_free() it is best to keep them apart as they may need to be
    // independent of each other if there needs to be a patch.
    function @rec (void) => bool brick_placement_allowed do
        return not pingu.head_collision_on_walk(0, 2);
    end

    function @rec (void) => void place_a_brick do
        bricks = bricks-1;
        name.set(_make_name(bricks));

        if bricks < 4 then
            _Sound_PingusSound_play_sound("ting");
        end

        if pingu.direction.is_right() then
            _world_put(_WorldObj__get_world(),
                       brick_r,
                       (int)(pingu.get_x() + 10.0 - (float)brick_r.get_width()),
                       (int)pingu.get_y(),
                       _GT_BRIDGE);
        else
            _world_put(_WorldObj__get_world(),
                       brick_l,
                       (int)(pingu.get_x() - 10.0),
                       (int)pingu.get_y(),
                       _GT_BRIDGE);
        end
    end

    function @rec (void) => void walk_one_step_up do
        pingu.set_posf(
            pingu.get_x() + 4.0*(float)(pingu.direction),
            pingu.get_y() - 2
        );
    end

    loop do
        x_offset = 6;
        y_offset = 4;

        if bricks == MAX_BRICKS then
            x_offset = -4;
            y_offset = 0;
        else/if bricks == MAX_BRICKS-1 then
            x_offset = 0;
            y_offset = 1;
        else/if bricks == MAX_BRICKS-2 then
            x_offset = 3;
            y_offset = 2;
        end

        x_offset = x_offset * (float)pingu.direction;

        //building step
        par/or do
            every global:e_PINGU_UPDATE_ALL do
                build_sprite.get(pingu.direction):update();
            end
        with
            every gc in pingu.e_DRAW_CALLED do
                var Vector3f p;
                p.x = pingu.get_pos().x - x_offset;
                p.y = pingu.get_pos().y + y_offset;
                p.z = pingu.get_pos().z;

                _gc_color_draw2(
                    gc,
                    build_sprite.get(pingu.direction),
                    _toVector3f(p)
                );
            end
        with
            await global:e_PINGU_UPDATE_ALL until (build_sprite.get(pingu.direction):get_current_frame () >= 7);

            if bricks > 0 then
                if call/rec brick_placement_allowed() then
                    call/rec place_a_brick();
                else
                    pingu.direction.change();
                    escape _A_WALKER;
                end
            else // Out of bricks
                escape _A_WAITER;
            end

            PRE_CONDITION_AWAIT(global:e_PINGU_UPDATE_ALL, build_sprite.get(pingu.direction):is_finished());

            build_sprite.get(pingu.direction):restart();
        end

        //walking step
        par/or do
            every global:e_PINGU_UPDATE_ALL do
                //original FIXME: Dangerous! might not be fixed timing
                if walk_sprite.get(pingu.direction):is_finished() then
                    break;
                end

                walk_sprite.update();
            end
        with
            every gc in pingu.e_DRAW_CALLED do
                var Vector3f p;
                p.x = pingu.get_pos().x - x_offset;
                p.y = pingu.get_pos().y + y_offset;
                p.z = pingu.get_pos().z;

                _gc_color_draw2(
                    gc,
                    walk_sprite.get(pingu.direction),
                    _toVector3f(p)
                );
            end
        end

        if call/rec way_is_free() then
            walk_sprite.get(pingu.direction):restart();
            call/rec walk_one_step_up();
        else // We reached a wall...
            pingu.direction.change();
            escape _A_WALKER;
        end
    end
end

#endif
