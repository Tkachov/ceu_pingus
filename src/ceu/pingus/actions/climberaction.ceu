#ifndef CLIMBERACTION_CEU
#define CLIMBERACTION_CEU

#include "../../c.ceu"
#include "../../sdl.ceu"
#include "../../engine/display/scene_context.ceu"
#include "../iaction.ceu"
#include "../ipingu.ceu"
#include "../state_sprite.ceu"

native/pre do
    ##include "pingus/actions/climber.hpp"
    ##define AClimber Actions::Climber
end

class ClimberAction with
    interface IAction;
do
    var _AClimber&? climber = _PTR2REF((_AClimber*)pingu.set_ptr(_A_CLIMBER));

    load_directions(climber.sprite, climber, "/climber/");

    par do
        every gc in pingu.e_DRAW_CALLED do
            _gc_color_draw(gc, climber.sprite[climber.pingu:direction], climber.pingu:get_pos());
        end
    with
        every pingu.e_UPDATE_CALLED do
            climber.sprite[climber.pingu:direction].update();

            //there's something above
            if climber.rel_getpixel(0, 1) != _GT_NOTHING and climber.rel_getpixel(0, 1) != _GT_BRIDGE then
                climber.pingu:direction.change();
                escape _A_WALKER;
            end

            //nothing above and there is still ground to walk on
            if climber.rel_getpixel(1, 1) != _GT_NOTHING then
                climber.pingu:set_pos(climber.pingu:get_x(), climber.pingu:get_y() - 1);
                continue;
            end

            // If Pingu able to get to new position without head collision
            if not _action_head_collision_on_walk(climber, climber.pingu:direction, 1) then
                // Get ready to walk
                climber.pingu:set_pos(
                    climber.pingu:get_x() + (float)climber.pingu:direction,
                    climber.pingu:get_y() - 1.0
                );
            else
                // Get ready to fall
                climber.pingu:direction.change();
            end

            // Finish climbing.
            escape _A_WALKER;
        end
    end
end

#endif
