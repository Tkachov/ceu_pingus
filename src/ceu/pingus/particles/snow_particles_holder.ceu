#ifndef SNOW_PARTICLES_HOLDER_CEU
#define SNOW_PARTICLES_HOLDER_CEU

#include "../../c.ceu"
#include "../../sdl.ceu"
#include "../iworld.ceu"
#include "../pingu_holder_listener.ceu"
#include "../worldobj.ceu"
#include "isnow_particles_holder.ceu"

native/pre do
    ##include "pingus/particles/snow_particle_holder.hpp"

    ##define Vector_SnowParticle std::vector<SnowParticle>
    ##define new_Vector_SnowParticle() new std::vector<SnowParticle>()
    ##define get_particle(p, i) &((*p)[i])
    ##define makeSnowParticle(x, y, c) SnowParticle(x, y, c)
end

native @pure _new_Vector_SnowParticle(),
             _get_particle(),
             _makeSnowParticle();

class SnowParticlesHolder with
    interface ISnowParticlesHolder;

    var _Sprite&? snow1;
    var _Sprite&? snow2;
    var _Sprite&? snow3;
    var _Sprite&? snow4;
    var _Sprite&? snow5;
    var _CollisionMask&? ground;
    var _Vector_SnowParticle&? particles;
do
    call/rec global:world:add_object(&this);

    function (_FileReader* reader) => void construct do end;

    function (void) => float get_z_pos do return 1000; end
    function (Vector3f p) => void set_pos do end
    function (void) => Vector3f get_pos do return pos; end

    finalize with
        _delete_obj(snow1);
        _delete_obj(snow2);
        _delete_obj(snow3);
        _delete_obj(snow4);
        _delete_obj(snow5);
        _delete_obj(ground);
        _delete_obj(particles);
    end

    function @rec (int x, int y, bool c) => void add_particle do
        //default c == false
        // search for dead entry to replace
        loop j in particles.size() do
            var _SnowParticle&? it = _get_particle(particles, j);

            if not it.alive then
                it = _makeSnowParticle(x, y, c);
                return;
            end
        end

        // create new entry
        particles.push_back(_makeSnowParticle(x, y, c));
    end

    par/or do
        every gc in e_DRAW do
            loop j in particles.size() do
                var _SnowParticle&? it = _get_particle(particles, j);

                if not it.alive then
                    continue;
                end

                if it.type == _Snow1 then gc:color().draw(_deref(snow1), it.pos) finalize with end;
                else/if it.type == _Snow2 then gc:color().draw(_deref(snow2), it.pos) finalize with end;
                else/if it.type == _Snow3 then gc:color().draw(_deref(snow3), it.pos) finalize with end;
                else/if it.type == _Snow4 then gc:color().draw(_deref(snow4), it.pos) finalize with end;
                else/if it.type == _Snow5 then gc:color().draw(_deref(snow5), it.pos) finalize with end;
                else _assert(not "Invalid Snow-Type"); end
            end
        end
    with
        every e_UPDATE do
            // update all contained particles
            loop j in particles.size() do
                var _SnowParticle&? it = _get_particle(particles, j);

                // skip dead particles
                if not it.alive then
                    continue;
                end

                it.pos.x = it.pos.x + it.velocity.x;
                it.pos.y = it.pos.y + it.velocity.y;

                if it.pos.y > global:world:get_height() then
                    it.alive = false;
                end

                if not it.alive then continue; end

                it.velocity.x = it.velocity.x + (_Math__frand() - 0.5)/10;

                if it.colliding then
                    var int pixel = global:world:world:get_colmap():getpixel(it.pos.x, it.pos.y) finalize with end;
                    if pixel != _GT_NOTHING and pixel != _GT_WATER and pixel != _GT_OUTOFSCREEN then
                        global:world:world:get_gfx_map():put(ground.get_surface(), it.pos.x-1, it.pos.y-1);
                        it.alive = false;
                    end
                end
            end
        end
    with
        await e_DELETE;
    end
end

#endif
